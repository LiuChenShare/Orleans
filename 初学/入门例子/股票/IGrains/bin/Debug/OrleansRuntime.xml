<?xml version="1.0"?>
<doc>
    <assembly>
        <name>OrleansRuntime</name>
    </assembly>
    <members>
        <member name="T:Orleans.Runtime.CancellationSourcesExtension">
            <summary>
            Contains list of cancellation token source corresponding to the tokens
            passed to the related grain activation.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.CancellationSourcesExtension.RegisterCancellationTokens(Orleans.Runtime.IAddressable,Orleans.CodeGeneration.InvokeMethodRequest,Orleans.Runtime.Logger,Orleans.Runtime.ISiloRuntimeClient)">
            <summary>
            Adds CancellationToken to the grain extension
            so that it can be cancelled through remote call to the CancellationSourcesExtension.
            </summary>
            <param name="target"></param>
            <param name="request"></param>
            <param name="logger"></param>
            <param name="siloRuntimeClient"></param>
        </member>
        <member name="F:Orleans.Runtime.ActivationState.Create">
            <summary>
            Activation is being created
            </summary>
        </member>
        <member name="F:Orleans.Runtime.ActivationState.Valid">
            <summary>
            Activation was successfully activated and ready to process requests.
            </summary>
        </member>
        <member name="F:Orleans.Runtime.ActivationState.Invalid">
            <summary>
            Tombstone for activation that was unable to be properly created
            </summary>
        </member>
        <member name="T:Orleans.Runtime.DefaultGrainActivator">
            <summary>
            <see cref="T:Orleans.Runtime.IGrainActivator"/> that uses type activation to create grains.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.DefaultGrainActivator.Create(Orleans.Runtime.IGrainActivationContext)">
            <inheritdoc />
        </member>
        <member name="M:Orleans.Runtime.DefaultGrainActivator.Release(Orleans.Runtime.IGrainActivationContext,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:Orleans.Runtime.IGrainActivationContext">
            <summary>
            The context associated with the current grain activation.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.IGrainActivationContext.GrainType">
            <summary>Gets the .NET type of the grain activation instance.</summary>
        </member>
        <member name="P:Orleans.Runtime.IGrainActivationContext.GrainIdentity">
            <summary>Gets the identity of the grain activation.</summary>
        </member>
        <member name="P:Orleans.Runtime.IGrainActivationContext.ActivationServices">
            <summary>Gets the <see cref="T:System.IServiceProvider"/> that provides access to the grain activation's service container.</summary>
        </member>
        <member name="T:Orleans.Runtime.GrainCreator">
            <summary>
            Helper class used to create local instances of grains. In the future this should be opened up for extension similar to ASP.NET's ControllerFactory.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.GrainCreator.#ctor(Orleans.Runtime.IGrainActivator,System.Func{Orleans.Runtime.IGrainRuntime},Orleans.Factory{Orleans.Grain,Orleans.GrainDirectory.IMultiClusterRegistrationStrategy,Orleans.Runtime.LogConsistency.ProtocolServices})">
            <summary>
            Initializes a new instance of the <see cref="T:Orleans.Runtime.GrainCreator"/> class.
            </summary>
            <param name="grainActivator">The activator used to used to create new grains</param>
            <param name="getGrainRuntime">The delegate used to get the grain runtime.</param>
            <param name="protocolServicesFactory"></param>
        </member>
        <member name="M:Orleans.Runtime.GrainCreator.CreateGrainInstance(Orleans.Runtime.IGrainActivationContext)">
            <summary>
            Create a new instance of a grain
            </summary>
            <param name="context">The <see cref="T:Orleans.Runtime.IGrainActivationContext"/> for the executing action.</param>
            <returns>The newly created grain.</returns>
        </member>
        <member name="M:Orleans.Runtime.GrainCreator.CreateGrainInstance(Orleans.Runtime.IGrainActivationContext,System.Type,Orleans.Core.IStorage)">
            <summary>
            Create a new instance of a grain
            </summary>
            <param name="context">The <see cref="T:Orleans.Runtime.IGrainActivationContext"/> for the executing action.</param>
            <param name="stateType">If the grain is a stateful grain, the type of the state it persists.</param>
            <param name="storage">If the grain is a stateful grain, the storage used to persist the state.</param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.GrainCreator.InstallLogViewAdaptor(Orleans.Grain,System.Type,System.Type,Orleans.GrainDirectory.IMultiClusterRegistrationStrategy,Orleans.LogConsistency.ILogViewAdaptorFactory,Orleans.Storage.IStorageProvider)">
            <summary>
            Install the log-view adaptor into a log-consistent grain.
            </summary>
            <param name="grain">The grain.</param>
            <param name="grainType">The grain type.</param>
            <param name="stateType">The type of the grain state.</param>
            <param name="mcRegistrationStrategy">The multi-cluster registration strategy.</param>
            <param name="factory">The consistency adaptor factory</param>
            <param name="storageProvider">The storage provider, or null if none needed</param>
            <returns>The newly created grain.</returns>
        </member>
        <member name="T:Orleans.Runtime.IGrainActivator">
            <summary>
            Provides methods to create a grain.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.IGrainActivator.Create(Orleans.Runtime.IGrainActivationContext)">
            <summary>
            Creates a grain.
            </summary>
            <param name="context">The <see cref="T:Orleans.Runtime.IGrainActivationContext"/> for the executing action.</param>
            <returns>An instantiated grain.</returns>
        </member>
        <member name="M:Orleans.Runtime.IGrainActivator.Release(Orleans.Runtime.IGrainActivationContext,System.Object)">
            <summary>
            Releases a controller.
            </summary>
            <param name="context">The <see cref="T:Orleans.Runtime.IGrainActivationContext"/> for the executing action.</param>
            <param name="grain">The grain to release.</param>
        </member>
        <member name="T:Orleans.Runtime.IInvokable">
            <summary>
            Common internal interface for SystemTarget and ActivationData.
            </summary>
        </member>
        <member name="T:Orleans.Runtime.ISiloRuntimeClient">
            <summary>
            Runtime client methods accessible on silos.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.ISiloRuntimeClient.GetStreamDirectory">
            <summary>
            Gets the stream directory.
            </summary>
            <returns>The stream directory.</returns>
        </member>
        <member name="M:Orleans.Runtime.ISiloRuntimeClient.TryAddExtension(Orleans.Runtime.IGrainExtension)">
            <summary>
            Attempts to add the provided extension handler to the currently executing grain.
            </summary>
            <param name="handler">The extension handler.</param>
            <returns><see langword="true"/> if the operation succeeded; <see langword="false" /> otherwise.</returns>
        </member>
        <member name="M:Orleans.Runtime.ISiloRuntimeClient.TryGetExtensionHandler``1(``0@)">
            <summary>
            Attempts to retrieve the specified extension type from the currently executing grain.
            </summary>
            <typeparam name="TExtension">The type of the extension.</typeparam>
            <param name="result">The extension, or <see langword="null" /> if it was not available.</param>
            <returns><see langword="true"/> if the operation succeeded; <see langword="false" /> otherwise.</returns>
        </member>
        <member name="M:Orleans.Runtime.ISiloRuntimeClient.RemoveExtension(Orleans.Runtime.IGrainExtension)">
            <summary>
            Removes the provided extension handler from the currently executing grain.
            </summary>
            <param name="handler">The extension handler to remove.</param>
        </member>
        <member name="M:Orleans.Runtime.ISiloRuntimeClient.BindExtension``2(System.Func{``0})">
            <summary>
            Binds an extension to the currently executing grain if it does not already have an extension of the specified
            <typeparamref name="TExtensionInterface"/>.
            </summary>
            <typeparam name="TExtension">The type of the extension (e.g. StreamConsumerExtension).</typeparam>
            <typeparam name="TExtensionInterface">The public interface type of the implementation.</typeparam>
            <param name="newExtensionFunc">A factory function that constructs a new extension object.</param>
            <returns>A tuple, containing first the extension and second an addressable reference to the extension's interface.</returns>
        </member>
        <member name="T:Orleans.Runtime.GrainMethodInvoker">
            <summary>
            Invokes a request on a grain.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.GrainMethodInvoker.#ctor(Orleans.Runtime.IAddressable,Orleans.CodeGeneration.InvokeMethodRequest,Orleans.CodeGeneration.IGrainMethodInvoker,System.Collections.Generic.List{Orleans.IGrainCallFilter},Orleans.InterfaceToImplementationMappingCache,Orleans.Providers.InvokeInterceptor)">
            <summary>
            Initializes a new instance of the <see cref="T:Orleans.Runtime.GrainMethodInvoker"/> class.
            </summary>
            <param name="grain">The grain.</param>
            <param name="request">The request.</param>
            <param name="rootInvoker">The generated invoker.</param>
            <param name="filters">The invocation interceptors.</param>
            <param name="interfaceToImplementationMapping">The implementation map.</param>
            <param name="invokeInterceptor">The deprecated silo-wide interceptor.</param>
        </member>
        <member name="P:Orleans.Runtime.GrainMethodInvoker.Grain">
            <inheritdoc />
        </member>
        <member name="P:Orleans.Runtime.GrainMethodInvoker.Method">
            <inheritdoc />
        </member>
        <member name="P:Orleans.Runtime.GrainMethodInvoker.Arguments">
            <inheritdoc />
        </member>
        <member name="P:Orleans.Runtime.GrainMethodInvoker.Result">
            <inheritdoc />
        </member>
        <member name="M:Orleans.Runtime.GrainMethodInvoker.Invoke">
            <inheritdoc />
        </member>
        <member name="T:Orleans.Runtime.SystemTargetExtensions">
            <summary>
            Extensions for <see cref="T:Orleans.Runtime.SystemTarget"/>.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.SystemTargetExtensions.ScheduleTask(Orleans.Runtime.SystemTarget,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Schedules the provided <paramref name="action"/> on the <see cref="T:Orleans.Runtime.SystemTarget"/>'s <see cref="T:Orleans.Runtime.ISchedulingContext"/>.
            </summary>
            <param name="self">The <see cref="T:Orleans.Runtime.SystemTarget"/>.</param>
            <param name="action">The action.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> which completes when the <paramref name="action"/> has completed.</returns>
        </member>
        <member name="M:Orleans.Runtime.SystemTargetExtensions.ScheduleTask(Orleans.Runtime.SystemTarget,System.Action)">
            <summary>
            Schedules the provided <paramref name="action"/> on the <see cref="T:Orleans.Runtime.SystemTarget"/>'s <see cref="T:Orleans.Runtime.ISchedulingContext"/>.
            </summary>
            <param name="self">The <see cref="T:Orleans.Runtime.SystemTarget"/>.</param>
            <param name="action">The action.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> which completes when the <paramref name="action"/> has completed.</returns>
        </member>
        <member name="T:Orleans.Runtime.IObjectPool`1">
            <summary>
            Simple object pool Interface.
            Objects allocated should be returned to the pool when disposed.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Orleans.Runtime.IObjectPool`1.Allocate">
            <summary>
            Allocates a pooled resource
            </summary>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.IObjectPool`1.Free(`0)">
            <summary>
            Returns a resource to the pool
            </summary>
            <param name="resource"></param>
        </member>
        <member name="T:Orleans.Runtime.PooledResource`1">
            <summary>
            Utility class to support pooled objects by allowing them to track the pook they came from and return to it when disposed
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Orleans.Runtime.PooledResource`1.Pool">
            <summary>
            The pool to return this resource to upon disposal.
            A pool must set this property upon resource allocation.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.PooledResource`1.SignalPurge">
            <summary>
            If this object is to be used in a fixed size object pool, this call should be
              overridden with the purge implementation that returns the object to the pool.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.PooledResource`1.Dispose">
            <summary>
            Returns item to pool
            </summary>
        </member>
        <member name="M:Orleans.Runtime.PooledResource`1.OnResetState">
            <summary>
            Notifies the object that it has been purged, so it can reset itself to
              the state of a newly allocated object.
            </summary>
        </member>
        <member name="T:Orleans.Runtime.Placement.IActivationSelector">
            <summary>
            Interface for activation selectors.
            </summary>
        </member>
        <member name="T:Orleans.Runtime.Placement.IActivationSelector`1">
            <summary>
            Interface for activation selectorsimplementing the specified strategy.
            </summary>
            <typeparam name="TStrategy">The placement strategy which this selector implements.</typeparam>
        </member>
        <member name="T:Orleans.Runtime.Placement.ClientObserversPlacementDirector">
            <summary>
            ClientObserversPlacementDirector is a director for routing requests to client observers.
            It uses RandomPlacementDirector.OnSelectActivation for looking up the activation in the directory 
            (looking up the gateway address that can forward that request to the client).
            It does not allow placing client observer activations.
            </summary>
        </member>
        <member name="T:Orleans.Runtime.Placement.PreferLocalPlacementDirector">
            <summary>
            PreferLocalPlacementDirector is a single activation placement.
            It is similar to RandomPlacementDirector except for how new activations are placed.
            When activation is requested (OnSelectActivation), it uses the same algorithm as RandomPlacementDirector to pick one if one already exists.
            That is, it checks with the Distributed Directory.
            If none exits, it prefers to place a new one in the local silo. If there are no races (only one silo at a time tries to activate this grain),
            the the local silo wins. In the case of concurrent activations of the first activation of this grain, only one silo wins.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Placement.ActivationCountPlacementDirector.SelectSiloGreedy(Orleans.Runtime.PlacementStrategy,Orleans.Runtime.GrainId,Orleans.Runtime.Placement.IPlacementRuntime)">
            <summary>
            Selects the best match from list of silos, updates local statistics.
            </summary>
            <note>
            This is equivalent with SelectSiloPowerOfK() with chooseHowMany = #Silos
            </note>
        </member>
        <member name="M:Orleans.Runtime.Placement.IPlacementRuntime.FastLookup(Orleans.Runtime.GrainId,Orleans.GrainDirectory.AddressesAndTag@)">
            <summary>
            Lookup locally known directory information for a target grain
            </summary>
            <param name="grain"></param>
            <param name="addresses">Local addresses will always be complete, remote may be partial</param>
            <returns>True if remote addresses are complete within freshness constraint</returns>
        </member>
        <member name="M:Orleans.Runtime.Placement.IPlacementRuntime.TryGetActivationData(Orleans.Runtime.ActivationId,Orleans.Runtime.ActivationData@)">
            <summary>
            Try to get the transaction state of the activation if it is available on this silo
            </summary>
            <param name="id"></param>
            <param name="activationData"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.ReminderService.GrainBasedReminderTable.RemoveRow(Orleans.Runtime.GrainReference,System.String,System.String)">
            <summary>
            Remove a row from the table
            </summary>
            <param name="grainRef"></param>
            <param name="reminderName"></param>
            <param name="eTag"></param>
            <returns>true if a row with <paramref name="grainRef"/> and <paramref name="reminderName"/> existed and was removed successfully, false otherwise</returns>
        </member>
        <member name="M:Orleans.Runtime.ReminderService.InMemoryRemindersTable.ReadRows(System.UInt32,System.UInt32)">
            <summary>
            Return all rows that have their GrainReference's.GetUniformHashCode() in the range (start, end]
            </summary>
            <param name="begin"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.ReminderService.InMemoryRemindersTable.ReadRow(Orleans.Runtime.GrainReference,System.String)">
            <summary>
            Return all rows that have their GrainReference's.GetUniformHashCode() in the range (start, end]
            </summary>
            <param name="grainRef"></param>
            <param name="reminderName"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.ReminderService.InMemoryRemindersTable.RemoveRow(Orleans.Runtime.GrainReference,System.String,System.String)">
            <summary>
            Remove a row from the table
            </summary>
            <param name="grainRef"></param>
            <param name="reminderName"></param>
            /// <param name="eTag"></param>
            <returns>true if a row with <paramref name="grainRef"/> and <paramref name="reminderName"/> existed and was removed successfully, false otherwise</returns>
        </member>
        <member name="M:Orleans.Runtime.ReminderService.LocalReminderService.Start">
            <summary>
            Attempt to retrieve reminders, that are my responsibility, from the global reminder table when starting this silo (reminder service instance)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.ReminderService.LocalReminderService.UnregisterReminder(Orleans.Runtime.IGrainReminder)">
            <summary>
            Stop the reminder locally, and remove it from the external storage system
            </summary>
            <param name="reminder"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.ReminderService.LocalReminderService.ReadAndUpdateReminders">
            <summary>
            Attempt to retrieve reminders from the global reminder table
            </summary>
        </member>
        <member name="M:Orleans.Runtime.ReminderService.LocalReminderService.AsyncTimerCallback(System.Object)">
            <summary>
            Local timer expired ... notify it as a 'tick' to the grain who registered this reminder
            </summary>
            <param name="rem">Reminder that this timeout represents</param>
        </member>
        <member name="T:Orleans.Runtime.GrainService">
            <summary>Base class for implementing a grain-like partitioned service with per silo instances of it automatically instantiated and started by silo runtime</summary>
        </member>
        <member name="P:Orleans.Runtime.GrainService.Logger">
            <summary>Logger instance to be used by grain service subclasses</summary>
        </member>
        <member name="P:Orleans.Runtime.GrainService.StoppedCancellationTokenSource">
            <summary>Token for signaling cancellation upon stopping of grain service</summary>
        </member>
        <member name="P:Orleans.Runtime.GrainService.RangeSerialNumber">
            <summary>Monotonically increasing serial number of the version of the ring range owned by the grain service instance</summary>
        </member>
        <member name="P:Orleans.Runtime.GrainService.RingRange">
            <summary>Range of the partitioning ring currently owned by the grain service instance</summary>
        </member>
        <member name="P:Orleans.Runtime.GrainService.Status">
            <summary>Status of the grain service instance</summary>
        </member>
        <member name="P:Orleans.Runtime.GrainService.Config">
            <summary>Configuration of service </summary>
        </member>
        <member name="M:Orleans.Runtime.GrainService.#ctor">
            <summary>Only to make Reflection happy</summary>
        </member>
        <member name="M:Orleans.Runtime.GrainService.#ctor(Orleans.Core.IGrainIdentity,Orleans.Runtime.Silo,Orleans.Runtime.Configuration.IGrainServiceConfiguration)">
            <summary>Constructor to use for grain services</summary>
        </member>
        <member name="M:Orleans.Runtime.GrainService.Init(System.IServiceProvider)">
            <summary>Invoked upon initialization of the service</summary>
        </member>
        <member name="M:Orleans.Runtime.GrainService.Start">
            <summary>Invoked when service is being started</summary>
        </member>
        <member name="M:Orleans.Runtime.GrainService.StartInBackground">
            <summary>Deferred part of initialization that executes after the service is already started (to speed up startup)</summary>
        </member>
        <member name="M:Orleans.Runtime.GrainService.Stop">
            <summary>Invoked when service is being stopped</summary>
        </member>
        <member name="M:Orleans.Runtime.GrainService.OnRangeChange(Orleans.Runtime.IRingRange,Orleans.Runtime.IRingRange,System.Boolean)">
            <summary>Invoked when the ring range owned by the service instance changes because of a change in the clsuter state</summary>
        </member>
        <member name="T:Orleans.Runtime.GrainService.GrainServiceStatus">
            <summary>Possible statuses of a grain service</summary>
        </member>
        <member name="F:Orleans.Runtime.GrainService.GrainServiceStatus.Booting">
            <summary>Initialization is in progress</summary>
        </member>
        <member name="F:Orleans.Runtime.GrainService.GrainServiceStatus.Started">
            <summary>Service successfully started</summary>
        </member>
        <member name="F:Orleans.Runtime.GrainService.GrainServiceStatus.Stopped">
            <summary>Service has been stopped</summary>
        </member>
        <member name="T:Orleans.Runtime.Services.GrainServiceClient`1">
            <summary>
            Proxies requests to the appropriate GrainService based on the appropriate Ring partitioning strategy.
            </summary>
            <typeparam name="TGrainService"></typeparam>
        </member>
        <member name="M:Orleans.Runtime.Services.GrainServiceClient`1.#ctor(System.IServiceProvider)">
            <summary>
            Currently we only support a single GrainService per Silo, when multiple are supported we will request the number of GrainServices to partition per silo here.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.Services.GrainServiceClient`1.GrainService">
            <summary>
            Resolves the correct GrainService responsible for actioning the request based on the CallingGrainReference
            </summary>
        </member>
        <member name="P:Orleans.Runtime.Services.GrainServiceClient`1.CallingGrainReference">
            <summary>
            Resolves the Grain Reference invoking this request.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Services.GrainServiceClient`1.MapGrainReferenceToSiloRing(Orleans.Runtime.GrainReference)">
            <summary>
            Moved from InsideRuntimeClient.cs
            </summary>
            <param name="grainRef"></param>
            <returns></returns>
        </member>
        <member name="T:Orleans.Runtime.SiloInitializationParameters">
            <summary>
            Parameters used to initialize a silo and values derived from those parameters.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.SiloInitializationParameters.#ctor(System.String,Orleans.Runtime.Silo.SiloType,Orleans.Runtime.Configuration.ClusterConfiguration)">
            <summary>
            Initializes a new instance of the <see cref="T:Orleans.Runtime.SiloInitializationParameters"/> class. 
            </summary>
            <param name="name">The name of this silo.</param>
            <param name="type">The type of this silo.</param>
            <param name="config">The cluster configuration.</param>
        </member>
        <member name="P:Orleans.Runtime.SiloInitializationParameters.Name">
            <summary>
            Gets the name of this silo.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.SiloInitializationParameters.Type">
            <summary>
            Gets the type of this silo.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.SiloInitializationParameters.ClusterConfig">
            <summary>
            Gets the cluster configuration.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.SiloInitializationParameters.GlobalConfig">
            <summary>
            Gets the global configuration.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.SiloInitializationParameters.NodeConfig">
            <summary>
            Gets the node configuration.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.SiloInitializationParameters.SiloAddress">
            <summary>
            Gets the address of this silo's inter-silo endpoint.
            </summary>
        </member>
        <member name="T:Orleans.Runtime.TestHooks.TestHooksSystemTarget">
            <summary>
            Test hook functions for white box testing implemented as a SystemTarget
            </summary>
        </member>
        <member name="T:Orleans.Runtime.Startup.StartupBuilder">
            <summary>
            Configure dependency injection at startup
            </summary>
        </member>
        <member name="T:Orleans.Runtime.Startup.IStartupBuilder">
            <summary>
            Interface for dynamic loading of ConfigureStartupBuilder
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Startup.IStartupBuilder.ConfigureStartup(System.String)">
            <summary>
            Configure dependency injection for startup of this silo.
            </summary>
            <param name="startupTypeName"></param>
            <returns></returns>
        </member>
        <member name="T:Orleans.Runtime.MultiClusterNetwork.MultiClusterData">
            <summary>
            Data stored and transmitted in the multicluster network. 
            IMPORTANT: these objects can represent full state, partial state, or delta.
            So far includes multicluster-configuration and multicluster-gateway information.
            Data is gossip-able.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.MultiClusterNetwork.MultiClusterData.Gateways">
            <summary>
            The dictionary of gateway entries and their current status.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.MultiClusterNetwork.MultiClusterData.Configuration">
            <summary>
            The admin-injected configuration.
            May be null if none has been injected yet, or if this object represents a partial state or delta.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.MultiClusterNetwork.MultiClusterData.IsEmpty">
            <summary>
            Whether there is actually any data in here.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.MultiClusterData.#ctor(System.Collections.Generic.IReadOnlyDictionary{Orleans.Runtime.SiloAddress,Orleans.Runtime.MultiClusterNetwork.GatewayEntry},Orleans.MultiCluster.MultiClusterConfiguration)">
            <summary>
            Construct MultiClusterData containing a collection of gateway entries and a multi-cluster configuration.
            </summary>
            <param name="d">The gateway entries, by SiloAddress</param>
            <param name="config">The configuration</param>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.MultiClusterData.#ctor">
            <summary>
            Construct empty MultiClusterData.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.MultiClusterData.#ctor(Orleans.Runtime.MultiClusterNetwork.GatewayEntry)">
            <summary>
            Construct MultiClusterData containing a single gateway entry.
            </summary>
            <param name="gatewayEntry">The gateway entry</param>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.MultiClusterData.#ctor(System.Collections.Generic.IEnumerable{Orleans.Runtime.MultiClusterNetwork.GatewayEntry})">
            <summary>
            Construct MultiClusterData containing a collection of gateway entries.
            </summary>
            <param name="gatewayEntries">The gateway entries, by SiloAddress</param>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.MultiClusterData.#ctor(Orleans.MultiCluster.MultiClusterConfiguration)">
            <summary>
            Construct MultiClusterData containing a multi-cluster configuration.
            </summary>
            <param name="config">The configuration</param>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.MultiClusterData.ToString">
            <summary>
            Display content of MultiCluster data as an (abbreviated) string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.MultiClusterData.IsActiveGatewayForCluster(Orleans.Runtime.SiloAddress,System.String)">
            <summary>
            Check whether a particular silo is an active gateway for a cluster
            </summary>
            <param name="address">the silo address</param>
            <param name="clusterid">the id of the cluster</param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.MultiClusterData.Merge(Orleans.Runtime.MultiClusterNetwork.MultiClusterData)">
            <summary>
             merge source into this object, and return result.
             Ignores expired entries in source, and removes expired entries from this.
            </summary>
            <param name="source">The source data to apply to the data in this object</param>
            <returns>The updated data</returns>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.MultiClusterData.Merge(Orleans.Runtime.MultiClusterNetwork.MultiClusterData,Orleans.Runtime.MultiClusterNetwork.MultiClusterData@)">
            <summary>
             incorporate source, producing new result, and report delta.
             Ignores expired entries in source, and removes expired entries from this.
            </summary>
            <param name="source">The source data to apply to the data in this object</param>
            <param name="delta">A delta of what changes were actually applied, used for change listeners</param>
            <returns>The updated data</returns>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.MultiClusterData.Minus(Orleans.Runtime.MultiClusterNetwork.MultiClusterData)">
            <summary>
            Returns all data of this object except for what keys appear in exclude
            </summary>
            <param name="exclude"></param>
            <returns></returns>
        </member>
        <member name="T:Orleans.Runtime.MultiClusterNetwork.GatewayEntry">
            <summary>
            Information about gateways, as stored/transmitted in the multicluster network.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.MultiClusterNetwork.GatewayEntry.ClusterId">
            <summary>
            The cluster id.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.MultiClusterNetwork.GatewayEntry.SiloAddress">
            <summary>
            The address of the silo.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.MultiClusterNetwork.GatewayEntry.Status">
            <summary>
            The gateway status of the silo (indicates whether this silo is currently acting as a gateway)
            </summary>
        </member>
        <member name="P:Orleans.Runtime.MultiClusterNetwork.GatewayEntry.HeartbeatTimestamp">
            <summary>
            UTC timestamp of this gateway entry.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.MultiClusterNetwork.GatewayEntry.Expired">
            <summary>
            Whether this entry has expired based on its timestamp.
            </summary>
        </member>
        <member name="F:Orleans.Runtime.MultiClusterNetwork.GatewayEntry.ExpiresAfter">
            <summary>
            time after which entries expire.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.GatewayEntry.Equals(Orleans.Runtime.MultiClusterNetwork.GatewayEntry)">
            <summary>
            Checks equality of all fields.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.GatewayEntry.Equals(System.Object)">
            <summary>
            Untyped version of Equals.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.GatewayEntry.GetHashCode">
            <summary>
            Overrides GetHashCode to conform with definition of Equals.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.GatewayEntry.ToString">
            <summary>
            create a string representation of the gateway info.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.MultiClusterNetwork.MultiClusterOracle.ProtocolMessageFilterForTesting">
            <inheritdoc/>
        </member>
        <member name="T:Orleans.Runtime.MultiClusterNetwork.IGossipChannel">
            <summary>
            Interface for gossip channel.
            
            A gossip channel stores multicluster data (configuration, gateways) and exchanges
            this data with silos using a gossip-style communication, offering
            two different methods (Publish or Synchronize).
            </summary>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.IGossipChannel.Initialize(System.Guid,System.String)">
            <summary>
            Initialize the channel with given configuration.
            </summary>
            <param name="serviceId"></param>
            <param name="connectionString"></param>
            <returns></returns>
        </member>
        <member name="P:Orleans.Runtime.MultiClusterNetwork.IGossipChannel.Name">
            <summary>
            A name for the channel.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.IGossipChannel.Publish(Orleans.Runtime.MultiClusterNetwork.MultiClusterData)">
            <summary>
            One-way small-scale gossip. 
            Used to update small amounts of data (e.g. multicluster configuration, single gateway status) in the channel.
            The passed-in data is stored only if it is newer than the already stored data.
            </summary>
            <param name="data">The data to update</param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.IGossipChannel.Synchronize(Orleans.Runtime.MultiClusterNetwork.MultiClusterData)">
            <summary>
            Two-way bulk gossip.
            - any passed-in information that is newer than stored information is stored.
            - any stored information that is newer than passed-in information is returned.
            </summary>
            <param name="gossipdata">The gossip data to compare to the current contents, and store if newer, or not there</param>
            <returns>returns all stored data that is newer, or not part of, the gossipdata</returns>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.IMultiClusterOracle.Start">
            <summary>
            Starts this instance.
            </summary>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> representing the work performed.</returns>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.IMultiClusterOracle.GetMultiClusterConfiguration">
            <summary>
            Get the latest multicluster configuration.
            </summary>
            <returns>The current multicluster configuration, or null if there is none</returns>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.IMultiClusterOracle.InjectMultiClusterConfiguration(Orleans.MultiCluster.MultiClusterConfiguration)">
            <summary>
            Inject a multicluster configuration. For this to have any effect, the timestamp must be newer 
            than the latest configuation stored in the multicluster network.
            </summary>
            <returns>A task that completes once information has propagated to the multicluster channels</returns>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.IMultiClusterOracle.IsFunctionalClusterGateway(Orleans.Runtime.SiloAddress)">
            <summary>
            Whether a gateway is functional (to the best knowledge of this node) 
            </summary>
            <param name="siloAddress">A gateway whose status we are interested in.</param>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.IMultiClusterOracle.FindLaggingSilos(Orleans.MultiCluster.MultiClusterConfiguration)">
            <summary>
            Contact all silos in all clusters, return silos that do not have the expected configuration.
            </summary>
            <returns>A dictionary containing silo addresses and the corresponding configuration for all non-matching configurations</returns>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.IMultiClusterOracle.GetActiveClusters">
            <summary>
            Returns a list of cluster ids for active clusters based on what gateways we have stored in the table.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.IMultiClusterOracle.GetGateways">
            <summary>
            Returns the list of currently known multicluster gateways.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.IMultiClusterOracle.GetRandomClusterGateway(System.String)">
            <summary>
            Returns one of the active cluster gateways for a given cluster.
            </summary>
            <param name="cluster">the cluster for which we want a gateway</param>
            <returns>a gateway address, or null if none is found for the given cluster</returns>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.IMultiClusterOracle.SubscribeToMultiClusterConfigurationEvents(Orleans.Runtime.GrainReference)">
            <summary>
            Subscribe to multicluster configuration change events.
            </summary>
            <param name="observer">An observer to receive configuration change notifications.</param>
            <returns>bool value indicating that subscription succeeded or not.</returns>
        </member>
        <member name="M:Orleans.Runtime.MultiClusterNetwork.IMultiClusterOracle.UnSubscribeFromMultiClusterConfigurationEvents(Orleans.Runtime.GrainReference)">
            <summary>
            UnSubscribe from multicluster configuration change events.
            </summary>
            <returns>bool value indicating that subscription succeeded or not.</returns>
        </member>
        <member name="P:Orleans.Runtime.MultiClusterNetwork.IMultiClusterOracle.ProtocolMessageFilterForTesting">
            <summary>
            A test hook for dropping protocol messages between replicated grain instances
            </summary>
        </member>
        <member name="T:Orleans.Runtime.GrainDirectory.ClusterGrainDirectory">
            <summary>
            This system target provides an entry point for remote clusters to call directory functions.
            Since remote clusters do not have ring information about this cluster, they cannot send 
            requests directly to the silo with the right directory partition
            unless they know the activation address already. Therefore,
            This class serves as an intermediary that forwards the requests to the correct silo.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.ClusterGrainDirectory.ProcessDeactivations(System.Collections.Generic.List{Orleans.Runtime.ActivationAddress})">
            <summary>
            Called by a remote cluster after it deactivates GSI grains, so this cluster can remove cached entries
            </summary>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.ClusterGrainDirectory.ProcessDeletion(Orleans.Runtime.GrainId)">
            <summary>
            Called by a remote cluster that wishes to eradicate all activations of a grain in all clusters
            </summary>
        </member>
        <member name="T:Orleans.Runtime.GrainDirectory.GlobalSingleInstanceResponseTracker">
            <summary>
            Utility that encapsulates Global Single Instance response processing logic.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.GlobalSingleInstanceResponseTracker.GetOutcome(Orleans.SystemTargetInterfaces.RemoteClusterActivationResponse[],Orleans.Runtime.GrainId,Orleans.Runtime.Logger)">
            <summary>
            Gets the outcome for a full round of responses from all the clusters.
            </summary>
            <param name="responses">Responses for a particular grain from all of the clusters in the multi-cluster network</param>
            <param name="grainId">The ID of the grain that we want to know its owner status</param>
            <param name="logger">The logger in case there is useful information to log.</param>
            <returns>The outcome of aggregating all of the responses.</returns>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.GlobalSingleInstanceResponseTracker.GetOutcomeAsync(System.Threading.Tasks.Task{Orleans.SystemTargetInterfaces.RemoteClusterActivationResponse}[],Orleans.Runtime.GrainId,Orleans.Runtime.Logger)">
            <summary>
            Gets the outcome for a full round of responses from all the clusters.
            </summary>
            <param name="responsePromises">Promises fot the responses for a particular grain from all of the clusters in the multi-cluster network</param>
            <param name="grainId">The ID of the grain that we want to know its owner status</param>
            <param name="logger">The logger in case there is useful information to log.</param>
            <returns>The outcome of aggregating all of the responses. The task will complete as soon as it has enough responses to make a determination, even if not all of the clusters responded yet.</returns>
        </member>
        <member name="P:Orleans.Runtime.GrainDirectory.GlobalSingleInstanceResponseTracker.Task">
            <summary>
            Returns the outcome of the response aggregation
            </summary>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.GlobalSingleInstanceResponseTracker.CheckIfDone">
            <summary>
            Check responses; signal completion if we have received enough responses to determine outcome.
            </summary>
        </member>
        <member name="T:Orleans.Runtime.GrainDirectory.GlobalSingleInstanceRegistrar">
            <summary>
            A grain registrar that coordinates the directory entries for a grain between
            all the clusters in the current multi-cluster configuration.
            It uses the global-single-instance protocol to ensure that there is eventually
            only a single owner for each grain. When a new grain is registered, all other clusters are
            contacted to see if an activation already exists. If so, a pointer to that activation is 
            stored in the directory and returned. Otherwise, the new activation is registered.
            The protocol uses special states to track the status of directory entries, as listed in 
            <see cref="T:Orleans.GrainDirectory.GrainDirectoryEntryStatus"/>.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.GlobalSingleInstanceRegistrar.SendRequest(Orleans.Runtime.GrainId,System.String)">
            <summary>
            Send GSI protocol request to the given remote cluster
            </summary>
            <param name="grain">The grainId of the grain being activated</param>
            <param name="remotecluster">The remote cluster name to send the request to.</param>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.MultiClusterUtils.ActivationPrecedenceFunc(Orleans.Runtime.GrainId,System.String,System.String)">
            <summary>
            Precedence function to resolve races among clusters that are trying to create an activation for a particular grain.
            </summary>
            <param name="grain">The GrainID under consideration.</param>
            <param name="clusterLeft"></param>
            <param name="clusterRight"></param>
            <returns>
            The function returns "true" if clusterLeft has precedence over clusterRight.
            </returns>
        </member>
        <member name="T:Orleans.Runtime.GrainDirectory.RegistrarManager">
            <summary>
            Maps multi-cluster registration strategies to the corresponding registrar
            </summary>
        </member>
        <member name="T:Orleans.Runtime.GrainDirectory.ClusterLocalRegistrar">
            <summary>
            The registrar for the Cluster-Local Registration Strategy.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.GrainDirectory.AdaptiveGrainDirectoryCache`1.GrainDirectoryCacheEntry.NumAccesses">
            <summary>
            flag notifying whether this cache entry was accessed lately 
            (more precisely, since the last refresh)
            </summary>
        </member>
        <member name="F:Orleans.Runtime.GrainDirectory.AdaptiveGrainDirectoryCache`1.initialExpirationTimer">
            controls the time the new entry is considered "fresh" (unit: ms)
        </member>
        <member name="F:Orleans.Runtime.GrainDirectory.AdaptiveGrainDirectoryCache`1.exponentialTimerGrowth">
            controls the exponential growth factor (i.e., x2, x4) for the freshness timer (unit: none)
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.AdaptiveDirectoryCacheMaintainer`1.BuildGrainAndETagList(System.Collections.Generic.IEnumerable{Orleans.Runtime.GrainId})">
            <summary>
            Gets the list of grains (all owned by the same silo) and produces a new list
            of tuples, where each tuple holds the grain and its generation counter currently stored in the cache
            </summary>
            <param name="grains">List of grains owned by the same silo</param>
            <returns>List of grains in input along with their generation counters stored in the cache </returns>
        </member>
        <member name="F:Orleans.Runtime.GrainDirectory.GrainDirectoryPartition.partitionData">
            <summary>
            contains a map from grain to its list of activations along with the version (etag) counter for the list
            </summary>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.GrainDirectoryPartition.GetItems">
            <summary>
            Returns all entries stored in the partition as an enumerable collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.GrainDirectoryPartition.AddActivation(Orleans.Runtime.GrainId,Orleans.Runtime.ActivationId,Orleans.Runtime.SiloAddress)">
            <summary>
            Adds a new activation to the directory partition
            </summary>
            <param name="grain"></param>
            <param name="activation"></param>
            <param name="silo"></param>
            <returns>The version associated with this directory mapping</returns>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.GrainDirectoryPartition.AddSingleActivation(Orleans.Runtime.GrainId,Orleans.Runtime.ActivationId,Orleans.Runtime.SiloAddress,Orleans.GrainDirectory.GrainDirectoryEntryStatus)">
            <summary>
            Adds a new activation to the directory partition
            </summary>
            <param name="grain"></param>
            <param name="activation"></param>
            <param name="silo"></param>
            <param name="registrationStatus"></param>
            <returns>The registered ActivationAddress and version associated with this directory mapping</returns>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.GrainDirectoryPartition.RemoveActivation(Orleans.Runtime.GrainId,Orleans.Runtime.ActivationId,Orleans.GrainDirectory.UnregistrationCause)">
            <summary>
            Removes an activation of the given grain from the partition
            </summary>
            <param name="grain">the identity of the grain</param>
            <param name="activation">the id of the activation</param>
            <param name="cause">reason for removing the activation</param>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.GrainDirectoryPartition.RemoveActivation(Orleans.Runtime.GrainId,Orleans.Runtime.ActivationId,Orleans.GrainDirectory.UnregistrationCause,Orleans.Runtime.IActivationInfo@,System.Boolean@)">
            <summary>
            Removes an activation of the given grain from the partition
            </summary>
            <param name="grain">the identity of the grain</param>
            <param name="activation">the id of the activation</param>
            <param name="cause">reason for removing the activation</param>
            <param name="entry">returns the entry, if found </param>
            <param name="wasRemoved">returns whether the entry was actually removed</param>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.GrainDirectoryPartition.RemoveGrain(Orleans.Runtime.GrainId)">
            <summary>
            Removes the grain (and, effectively, all its activations) from the diretcory
            </summary>
            <param name="grain"></param>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.GrainDirectoryPartition.LookUpActivations(Orleans.Runtime.GrainId)">
            <summary>
            Returns a list of activations (along with the version number of the list) for the given grain.
            If the grain is not found, null is returned.
            </summary>
            <param name="grain"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.GrainDirectoryPartition.TryGetActivation(Orleans.Runtime.GrainId,Orleans.Runtime.ActivationAddress@,System.Int32@)">
            <summary>
            Returns the activation of a single-activation grain, if present.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.GrainDirectoryPartition.GetGrainETag(Orleans.Runtime.GrainId)">
            <summary>
            Returns the version number of the list of activations for the grain.
            If the grain is not found, -1 is returned.
            </summary>
            <param name="grain"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.GrainDirectoryPartition.Merge(Orleans.Runtime.GrainDirectory.GrainDirectoryPartition)">
            <summary>
            Merges one partition into another, assuming partitions are disjoint.
            This method is supposed to be used by handoff manager to update the partitions when the system view (set of live silos) changes.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.GrainDirectoryPartition.Split(System.Predicate{Orleans.Runtime.GrainId},System.Boolean)">
            <summary>
            Runs through all entries in the partition and moves/copies (depending on the given flag) the
            entries satisfying the given predicate into a new partition.
            This method is supposed to be used by handoff manager to update the partitions when the system view (set of live silos) changes.
            </summary>
            <param name="predicate">filter predicate (usually if the given grain is owned by particular silo)</param>
            <param name="modifyOrigin">flag controling whether the source partition should be modified (i.e., the entries should be moved or just copied) </param>
            <returns>new grain directory partition containing entries satisfying the given predicate</returns>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.GrainDirectoryPartition.Set(System.Collections.Generic.Dictionary{Orleans.Runtime.GrainId,Orleans.Runtime.IGrainInfo})">
            <summary>
            Sets the internal parition dictionary to the one given as input parameter.
            This method is supposed to be used by handoff manager to update the old partition with a new partition.
            </summary>
            <param name="newPartitionData">new internal partition dictionary</param>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.GrainDirectoryPartition.Update(System.Collections.Generic.Dictionary{Orleans.Runtime.GrainId,Orleans.Runtime.IGrainInfo})">
            <summary>
            Updates partition with a new delta of changes.
            This method is supposed to be used by handoff manager to update the partition with a set of delta changes.
            </summary>
            <param name="newPartitionDelta">dictionary holding a set of delta updates to this partition.
            If the value for a given key in the delta is valid, then existing entry in the partition is replaced.
            Otherwise, i.e., if the value is null, the corresponding entry is removed.
            </param>
        </member>
        <member name="T:Orleans.Runtime.GrainDirectory.GrainDirectoryHandoffManager">
            <summary>
            Most methods of this class are synchronized since they might be called both
            from LocalGrainDirectory on CacheValidator.SchedulingContext and from RemoteGrainDirectory.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.IGrainDirectoryCache`1.AddOrUpdate(Orleans.Runtime.GrainId,`0,System.Int32)">
            <summary>
            Adds a new entry with the given version into the cache: key (grain) --> value
            The new entry will override any existing entry under the given key, 
            regardless of the stored version
            </summary>
            <param name="key">key to add</param>
            <param name="value">value to add</param>
            <param name="version">version for the value</param>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.IGrainDirectoryCache`1.Remove(Orleans.Runtime.GrainId)">
            <summary>
            Removes an entry from the cache given its key
            </summary>
            <param name="key">key to remove</param>
            <returns>True iff the enrty was in the cache and the removal was succeful</returns>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.IGrainDirectoryCache`1.Clear">
            <summary>
            Clear the cache, deleting all entries.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.IGrainDirectoryCache`1.LookUp(Orleans.Runtime.GrainId,`0@,System.Int32@)">
            <summary>
            Looks uo the cached value and version by the given key
            </summary>
            <param name="key">key for the lookup</param>
            <param name="result">value if the key is found, undefined otherwise</param>
            <param name="version">version of cached value if the key is found, undefined otherwise</param>
            <returns>true iff the the given key is in the cache</returns>
        </member>
        <member name="P:Orleans.Runtime.GrainDirectory.IGrainDirectoryCache`1.KeyValues">
            <summary>
            Returns list of key-value-version tuples stored currently in the cache.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.GrainDirectoryCacheExtensions.LookUp``1(Orleans.Runtime.GrainDirectory.IGrainDirectoryCache{``0},Orleans.Runtime.GrainId,``0@)">
            <summary>
            Looks up the cached value by the given key.
            </summary>
            <param name="cache">grain directory cache to look up results from</param>
            <param name="key">key for the lookup</param>
            <param name="result">value if the key is found, undefined otherwise</param>
            <returns>true iff the the given key is in the cache</returns>
        </member>
        <member name="F:Orleans.Runtime.GrainDirectory.LocalGrainDirectory.membershipRingList">
            <summary>
            list of silo members sorted by the hash value of their address
            </summary>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.LocalGrainDirectory.SetSiloRemovedCatalogCallback(System.Action{Orleans.Runtime.SiloAddress,Orleans.Runtime.SiloStatus})">
            <inheritdoc />
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.LocalGrainDirectory.AdjustLocalDirectory(Orleans.Runtime.SiloAddress)">
            <summary>
            Adjust local directory following the removal of a silo by droping all activations located on the removed silo
            </summary>
            <param name="removedSilo"></param>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.LocalGrainDirectory.AdjustLocalCache(Orleans.Runtime.SiloAddress)">
            Adjust local cache following the removal of a silo by droping:
            1) entries that point to activations located on the removed silo 
            2) entries for grains that are now owned by this silo (me)
            3) entries for grains that were owned by this removed silo - we currently do NOT do that.
                If we did 3, we need to do that BEFORE we change the membershipRingList (based on old Membership).
                We don't do that since first cache refresh handles that. 
                Second, since Membership events are not guaranteed to be ordered, we may remove a cache entry that does not really point to a failed silo.
                To do that properly, we need to store for each cache entry who was the directory owner that registered this activation (the original partition owner). 
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CalculateTargetSilo(Orleans.Runtime.GrainId,System.Boolean)">
            <summary>
            Finds the silo that owns the directory information for the given grain ID.
            This routine will always return a non-null silo address unless the excludeThisSiloIfStopping parameter is true,
            this is the only silo known, and this silo is stopping.
            </summary>
            <param name="grainId"></param>
            <param name="excludeThisSiloIfStopping"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.LocalGrainDirectory.GetPrimaryForGrain(Orleans.Runtime.GrainId)">
            <summary>
            For testing purposes only.
            Returns the silo that this silo thinks is the primary owner of directory information for
            the provided grain ID.
            </summary>
            <param name="grain"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.LocalGrainDirectory.GetSilosHoldingDirectoryInformationForGrain(Orleans.Runtime.GrainId)">
            <summary>
            For testing purposes only.
            Returns the silos that this silo thinks hold copies of the directory information for
            the provided grain ID.
            </summary>
            <param name="grain"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.LocalGrainDirectory.GetLocalDataForGrain(Orleans.Runtime.GrainId,System.Boolean@)">
            <summary>
            For testing purposes only.
            Returns the directory information held by the local silo for the provided grain ID.
            The result will be null if no information is held.
            </summary>
            <param name="grain"></param>
            <param name="isPrimary"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.ILocalGrainDirectory.Start">
            <summary>
            Starts the local portion of the directory service.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.ILocalGrainDirectory.Stop(System.Boolean)">
            <summary>
            Stops the local portion of the directory service.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.ILocalGrainDirectory.UnregisterAfterNonexistingActivation(Orleans.Runtime.ActivationAddress,Orleans.Runtime.SiloAddress)">
            <summary>
            Removes the record for an non-existing activation from the directory service.
            This is used when a request is received for an activation that cannot be found, 
            to lazily clean up the remote directory.
            The timestamp is used to prevent removing a valid entry in a possible (but unlikely)
            race where a request is received for a new activation before the request that causes the
            new activation to be created.
            Note that this method is a no-op if the global configuration parameter DirectoryLazyDeregistrationDelay
            is a zero or negative TimeSpan.
            <para>This method must be called from a scheduler thread.</para>
            </summary>
            <param name="address">The address of the activation to remove.</param>
            <param name="origin"> the silo from which the message to the non-existing activation was sent</param>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.ILocalGrainDirectory.LocalLookup(Orleans.Runtime.GrainId,Orleans.GrainDirectory.AddressesAndTag@)">
            <summary>
            Fetches locally known directory information for a grain.
            If there is no local information, either in the cache or in this node's directory partition,
            then this method will return false and leave the list empty.
            </summary>
            <param name="grain">The ID of the grain to look up.</param>
            <param name="addresses">An output parameter that receives the list of locally-known activations of the grain.</param>
            <returns>True if remote addresses are complete within freshness constraint</returns>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.ILocalGrainDirectory.LookupInCluster(Orleans.Runtime.GrainId,System.String)">
            <summary>
            Fetches complete directory information for a grain in an explicitly named cluster.
            <para>This method must be called from a scheduler thread.</para>
            </summary>
            <param name="grain">The ID of the grain to look up.</param>
            <param name="clusterId">The cluster in which to look up the grain</param>
            <returns>A list of all known activations of the grain, and the e-tag.</returns>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.ILocalGrainDirectory.InvalidateCacheEntry(Orleans.Runtime.ActivationAddress,System.Boolean)">
            <summary>
            Invalidates cache entry for the given activation address.
            This method is intended to be called whenever a directory client tries to access 
            an activation returned from the previous directory lookup and gets a reject from the target silo 
            notifiying him that the activation does not exist.
            </summary>
            <param name="activation">The address of the activation that needs to be invalidated in the directory cache for the given grain.</param>
            <param name="invalidateDirectoryAlso">If true, on owner, invalidates directory entry that point to activatiosn in remote clusters as well</param>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.ILocalGrainDirectory.GetPrimaryForGrain(Orleans.Runtime.GrainId)">
            <summary>
            For testing purposes only.
            Returns the silo that this silo thinks is the primary owner of directory information for
            the provided grain ID.
            </summary>
            <param name="grain"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.ILocalGrainDirectory.GetSilosHoldingDirectoryInformationForGrain(Orleans.Runtime.GrainId)">
            <summary>
            For testing purposes only.
            Returns the silos that this silo thinks hold copied directory information for
            the provided grain ID.
            </summary>
            <param name="grain"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.ILocalGrainDirectory.GetLocalDataForGrain(Orleans.Runtime.GrainId,System.Boolean@)">
            <summary>
            For testing purposes only.
            Returns the directory information held by another silo for the provided grain ID.
            The result will be null if no information is held.
            </summary>
            <param name="grain"></param>
            <param name="isPrimary"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.ILocalGrainDirectory.GetLocalDirectoryData(Orleans.Runtime.GrainId)">
            <summary>
            Returns the directory information held in a local directory partition for the provided grain ID.
            The result will be null if no information is held.
            </summary>
            <param name="grain"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.ILocalGrainDirectory.GetLocalCacheData(Orleans.Runtime.GrainId)">
            <summary>
            For testing and troubleshhoting purposes only.
            Returns the directory information held in a local directory cacche for the provided grain ID.
            The result will be null if no information is held.
            </summary>
            <param name="grain"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.ILocalGrainDirectory.IsSiloInCluster(Orleans.Runtime.SiloAddress)">
            <summary>
            For determining message forwarding logic, we sometimes check if a silo is part of this cluster or not
            </summary>
            <param name="silo">the address of the silo</param>
            <returns>true if the silo is known to be part of this cluster</returns>
        </member>
        <member name="P:Orleans.Runtime.GrainDirectory.ILocalGrainDirectory.ClusterId">
            <summary>
            The id of this cluster
            </summary>
        </member>
        <member name="M:Orleans.Runtime.GrainDirectory.ILocalGrainDirectory.SetSiloRemovedCatalogCallback(System.Action{Orleans.Runtime.SiloAddress,Orleans.Runtime.SiloStatus})">
            <summary>
            Sets the callback to <see cref="T:Orleans.Runtime.Catalog"/> which is called when a silo is removed from membership.
            </summary>
            <param name="catalogOnSiloRemoved">The callback.</param>
        </member>
        <member name="T:Orleans.Runtime.ISiloStatusListener">
            <summary>
            Interface for types which listen to silo status change notifications.
            </summary>
            <remarks>
            To be implemented by different in-silo runtime components that are interested in silo status notifications from ISiloStatusOracle.
            </remarks>
        </member>
        <member name="M:Orleans.Runtime.ISiloStatusListener.SiloStatusChangeNotification(Orleans.Runtime.SiloAddress,Orleans.Runtime.SiloStatus)">
            <summary>
            Receive notifications about silo status events. 
            </summary>
            <param name="updatedSilo">A silo to update about.</param>
            <param name="status">The status of a silo.</param>
        </member>
        <member name="T:Orleans.Runtime.ISiloStatusOracle">
            <summary>
            Authoritative local, per-silo source for information about the status of other silos.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.ISiloStatusOracle.CurrentStatus">
            <summary>
            Current status of this silo.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.ISiloStatusOracle.SiloName">
            <summary>
            Name of this silo.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.ISiloStatusOracle.SiloAddress">
            <summary>
            Silo Address of this silo.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.ISiloStatusOracle.Start">
            <summary>
            Start this oracle. Will register this silo in the SiloDirectory with SiloStatus.Starting status.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.ISiloStatusOracle.BecomeActive">
            <summary>
            Turns this oracle into an Active state. Will update this silo in the SiloDirectory with SiloStatus.Active status.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.ISiloStatusOracle.ShutDown">
            <summary>
            ShutDown this oracle. Will update this silo in the SiloDirectory with SiloStatus.ShuttingDown status. 
            </summary>
        </member>
        <member name="M:Orleans.Runtime.ISiloStatusOracle.Stop">
            <summary>
            Stop this oracle. Will update this silo in the SiloDirectory with SiloStatus.Stopping status. 
            </summary>
        </member>
        <member name="M:Orleans.Runtime.ISiloStatusOracle.KillMyself">
            <summary>
            Completely kill this oracle. Will update this silo in the SiloDirectory with SiloStatus.Dead status. 
            </summary>
        </member>
        <member name="M:Orleans.Runtime.ISiloStatusOracle.GetApproximateSiloStatus(Orleans.Runtime.SiloAddress)">
            <summary>
            Get the status of a given silo. 
            This method returns an approximate view on the status of a given silo. 
            In particular, this oracle may think the given silo is alive, while it may already have failed.
            If this oracle thinks the given silo is dead, it has been authoratively told so by ISiloDirectory.
            </summary>
            <param name="siloAddress">A silo whose status we are interested in.</param>
            <returns>The status of a given silo.</returns>
        </member>
        <member name="M:Orleans.Runtime.ISiloStatusOracle.GetApproximateSiloStatuses(System.Boolean)">
            <summary>
            Get the statuses of all silo. 
            This method returns an approximate view on the statuses of all silo.
            </summary>
            <param name="onlyActive">Include only silo who are currently considered to be active. If false, inlude all.</param>
            <returns>A list of silo statuses.</returns>
        </member>
        <member name="M:Orleans.Runtime.ISiloStatusOracle.GetApproximateMultiClusterGateways">
            <summary>
            Get a list of silos that are designated to function as gateways.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.ISiloStatusOracle.TryGetSiloName(Orleans.Runtime.SiloAddress,System.String@)">
            <summary>
            Get the name of a silo. 
            Silo name is assumed to be static and does not change across restarts of the same silo.
            </summary>
            <param name="siloAddress">A silo whose name we are interested in.</param>
            <param name="siloName">A silo name.</param>
            <returns>TTrue if could return the requested name, false otherwise.</returns>
        </member>
        <member name="M:Orleans.Runtime.ISiloStatusOracle.IsFunctionalDirectory(Orleans.Runtime.SiloAddress)">
            <summary>
            Determine if the current silo is valid for creating new activations on or for directoy lookups.
            </summary>
            <returns>The silo so ask about.</returns>
        </member>
        <member name="M:Orleans.Runtime.ISiloStatusOracle.IsDeadSilo(Orleans.Runtime.SiloAddress)">
            <summary>
            Determine if the current silo is dead.
            </summary>
            <returns>The silo so ask about.</returns>
        </member>
        <member name="M:Orleans.Runtime.ISiloStatusOracle.SubscribeToSiloStatusEvents(Orleans.Runtime.ISiloStatusListener)">
            <summary>
            Subscribe to status events about all silos. 
            </summary>
            <param name="observer">An observer async interface to receive silo status notifications.</param>
            <returns>bool value indicating that subscription succeeded or not.</returns>
        </member>
        <member name="M:Orleans.Runtime.ISiloStatusOracle.UnSubscribeFromSiloStatusEvents(Orleans.Runtime.ISiloStatusListener)">
            <summary>
            UnSubscribe from status events about all silos. 
            </summary>
            <returns>bool value indicating that subscription succeeded or not.</returns>
        </member>
        <member name="T:Orleans.Runtime.Messaging.IOutboundMessageQueue">
            <summary>
            Used for controlling message delverye
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Messaging.IOutboundMessageQueue.Start">
            <summary>
            Start operation
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Messaging.IOutboundMessageQueue.Stop">
            <summary>
            Stop operation
            </summary>
        </member>
        <member name="P:Orleans.Runtime.Messaging.IOutboundMessageQueue.Count">
            <summary>
            Current queue length
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Messaging.Gateway.TryDeliverToProxy(Orleans.Runtime.Message)">
            <summary>
            See if this message is intended for a grain we're proxying, and queue it for delivery if so.
            </summary>
            <param name="msg"></param>
            <returns>true if the message should be delivered to a proxied grain, false if not.</returns>
        </member>
        <member name="M:Orleans.Runtime.Messaging.GatewayAcceptor.HandleMessage(Orleans.Runtime.Message,System.Net.Sockets.Socket)">
            <summary>
            Handles an incoming (proxied) message by rerouting it immediately and unconditionally,
            after some header massaging.
            </summary>
            <param name="msg"></param>
            <param name="receivedOnSocket"></param>
        </member>
        <member name="M:Orleans.Runtime.Messaging.IncomingMessageAcceptor.StartAccept(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            Begins an operation to accept a connection request from the client.
            </summary>
            <param name="acceptEventArg">The context object to use when issuing 
            the accept operation on the server's listening socket.</param>
        </member>
        <member name="M:Orleans.Runtime.Messaging.IncomingMessageAcceptor.ProcessAccept(System.Net.Sockets.SocketAsyncEventArgs,System.Boolean)">
            <summary>
            Process the accept for the socket listener.
            </summary>
            <param name="e">SocketAsyncEventArg associated with the completed accept operation.</param>
            <param name="completedSynchronously">Shows whether AcceptAsync completed synchronously, 
            if true - the next accept operation woun't be started. Used for avoiding potential stack overflows.</param>
        </member>
        <member name="M:Orleans.Runtime.Messaging.IncomingMessageAcceptor.ProcessReceive(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            This method is invoked when an asynchronous receive operation completes. 
            If the remote host closed the connection, then the socket is closed. 
            </summary>
            <param name="e">SocketAsyncEventArg associated with the completed receive operation.</param>
        </member>
        <member name="M:Orleans.Runtime.Messaging.MessageCenter.BlockApplicationMessages">
            <summary>
            Indicates that application messages should be blocked from being sent or received.
            This method is used by the "fast stop" process.
            <para>
            Specifically, all outbound application messages are dropped, except for rejections and messages to the membership table grain.
            Inbound application requests are rejected, and other inbound application messages are dropped.
            </para>
            </summary>
        </member>
        <member name="M:Orleans.Runtime.ISiloStatisticsChangeListener.SiloStatisticsChangeNotification(Orleans.Runtime.SiloAddress,Orleans.Runtime.SiloRuntimeStatistics)">
            <summary>
            Receive notification when new statistics data arrives.
            </summary>
            <param name="updatedSilo">Updated silo.</param>
            <param name="newStats">New Silo statistics.</param>
        </member>
        <member name="T:Orleans.Runtime.ActivationData">
            <summary>
            Maintains additional per-activation state that is required for Orleans internal operations.
            MUST lock this object for any concurrent access
            Consider: compartmentalize by usage, e.g., using separate interfaces for data for catalog, etc.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.ActivationData.ExtensionInvoker.TryAddExtension(Orleans.CodeGeneration.IGrainExtensionMethodInvoker,Orleans.Runtime.IGrainExtension)">
            <summary>
            Try to add an extension for the specific interface ID.
            Fail and return false if there is already an extension for that interface ID.
            Note that if an extension invoker handles multiple interface IDs, it can only be associated
            with one of those IDs when added, and so only conflicts on that one ID will be detected and prevented.
            </summary>
            <param name="invoker"></param>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.ActivationData.ExtensionInvoker.Remove(Orleans.Runtime.IGrainExtension)">
            <summary>
            Removes all extensions for the specified interface id.
            Returns true if the chained invoker no longer has any extensions and may be safely retired.
            </summary>
            <param name="extension"></param>
            <returns>true if the chained invoker is now empty, false otherwise</returns>
        </member>
        <member name="M:Orleans.Runtime.ActivationData.ExtensionInvoker.Invoke(Orleans.Runtime.IAddressable,Orleans.CodeGeneration.InvokeMethodRequest)">
            <summary>
            Invokes the appropriate grain or extension method for the request interface ID and method ID.
            First each extension invoker is tried; if no extension handles the request, then the base
            invoker is used to handle the request.
            The base invoker will throw an appropriate exception if the request is not recognized.
            </summary>
            <param name="grain"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.ActivationData.ExtensionInvoker.TryGetExtension(System.Int32,Orleans.Runtime.IGrainExtension@)">
            <summary>
            Gets the extension from this instance if it is available.
            </summary>
            <param name="interfaceId">The interface id.</param>
            <param name="extension">The extension.</param>
            <returns>
            <see langword="true"/> if the extension is found, <see langword="false"/> otherwise.
            </returns>
        </member>
        <member name="P:Orleans.Runtime.ActivationData.ForwardingAddress">
            <summary>
            If State == Invalid, this may contain a forwarding address for incoming messages
            </summary>
        </member>
        <member name="P:Orleans.Runtime.ActivationData.InFlightCount">
            <summary>
            Number of messages that are actively being processed [as opposed to being in the Waiting queue].
            In most cases this will be 0 or 1, but for Reentrant grains can be >1.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.ActivationData.EnqueuedOnDispatcherCount">
            <summary>
            Number of messages that are being received [as opposed to being in the scheduler queue or actively processed].
            </summary>
        </member>
        <member name="M:Orleans.Runtime.ActivationData.IncrementInFlightCount">
            <summary>Increment the number of in-flight messages currently being processed.</summary>
        </member>
        <member name="M:Orleans.Runtime.ActivationData.DecrementInFlightCount">
            <summary>Decrement the number of in-flight messages currently being processed.</summary>
        </member>
        <member name="M:Orleans.Runtime.ActivationData.IncrementEnqueuedOnDispatcherCount">
            <summary>Increment the number of messages currently in the prcess of being received.</summary>
        </member>
        <member name="M:Orleans.Runtime.ActivationData.DecrementEnqueuedOnDispatcherCount">
            <summary>Decrement the number of messages currently in the prcess of being received.</summary>
        </member>
        <member name="F:Orleans.Runtime.ActivationData.waiting">
            <summary>
            grouped by sending activation: responses first, then sorted by id
            </summary>
        </member>
        <member name="M:Orleans.Runtime.ActivationData.EnqueueMessage(Orleans.Runtime.Message)">
            <summary>
            Insert in a FIFO order
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Orleans.Runtime.ActivationData.CheckOverloaded(Orleans.Runtime.Logger)">
            <summary>
            Check whether this activation is overloaded. 
            Returns LimitExceededException if overloaded, otherwise <c>null</c>c>
            </summary>
            <param name="log">Logger to use for reporting any overflow condition</param>
            <returns>Returns LimitExceededException if overloaded, otherwise <c>null</c>c></returns>
        </member>
        <member name="M:Orleans.Runtime.ActivationData.GetIdleness(System.DateTime)">
            <summary>
            Returns how long this activation has been idle.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.ActivationData.IsStale(System.DateTime)">
            <summary>
            Returns whether this activation has been idle long enough to be collected.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.ActivationData.PrintWaitingQueue">
            <summary>
            Return string containing dump of the queue of waiting work items
            </summary>
            <returns></returns>
            <remarks>Note: Caller must be holding lock on this activation while calling this method.</remarks>
        </member>
        <member name="M:Orleans.Runtime.IActivationCollector.ScheduleCollection(Orleans.Runtime.ActivationData)">
            <summary>
            Schedule collection.
            </summary>
            <param name="item">The activation to be scheduled.</param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.IActivationCollector.TryRescheduleCollection(Orleans.Runtime.ActivationData)">
            <summary>
            Attempt to reschedule collection.
            </summary>
            <param name="item">The activation to be rescheduled.</param>
            <returns></returns>
        </member>
        <member name="T:Orleans.Runtime.Counters.CountersStatistics">
            <summary>
            Background publisher of counter values.
            Updates to counters needs to be very fast, so are all in-memory operations.
            This class then follows up to periodically write the counter values to OS
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Counters.CountersStatistics.#ctor(System.TimeSpan)">
            <summary>
            Initialize the counter publisher framework. Start the background stats writer thread.
            </summary>
            <param name="writeInterval">Frequency of writing to Windows perf counters</param>
        </member>
        <member name="M:Orleans.Runtime.Counters.CountersStatistics.Start">
            <summary>
            Start stats collection
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Counters.CountersStatistics.Stop">
            <summary>
            Stop stats collection
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Counters.CountersStatistics.TimerTick(System.Object)">
            <summary>
            Handle a timer tick
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:Orleans.Runtime.ConsistentRing.IConsistentRingProvider.GetMyRange">
            <summary>
            Get the responsbility range of the current silo
            </summary>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.ConsistentRing.IConsistentRingProvider.SubscribeToRangeChangeEvents(Orleans.Runtime.ConsistentRing.IRingRangeListener)">
            <summary>
            Subscribe to receive range change notifications
            </summary>
            <param name="observer">An observer interface to receive range change notifications.</param>
            <returns>bool value indicating that subscription succeeded or not.</returns>
        </member>
        <member name="M:Orleans.Runtime.ConsistentRing.IConsistentRingProvider.UnSubscribeFromRangeChangeEvents(Orleans.Runtime.ConsistentRing.IRingRangeListener)">
            <summary>
            Unsubscribe from receiving range change notifications
            </summary>
            <param name="observer">An observer interface to receive range change notifications.</param>
            <returns>bool value indicating that unsubscription succeeded or not</returns>
        </member>
        <member name="M:Orleans.Runtime.ConsistentRing.IConsistentRingProvider.GetPrimaryTargetSilo(System.UInt32)">
            <summary>
            Get the silo responsible for <paramref name="key"/> according to consistent hashing
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:Orleans.Runtime.ConsistentRing.ConsistentRingProvider">
            <summary>
            We use the 'backward/clockwise' definition to assign responsibilities on the ring. 
            E.g. in a ring of nodes {5, 10, 15} the responsible for key 7 is 10 (the node is responsible for its predecessing range). 
            The backwards/clockwise approach is consistent with many overlays, e.g., Chord, Cassandra, etc.
            Note: MembershipOracle uses 'forward/counter-clockwise' definition to assign responsibilities. 
            E.g. in a ring of nodes {5, 10, 15}, the responsible of key 7 is node 5 (the node is responsible for its sucessing range)..
            </summary>
        </member>
        <member name="F:Orleans.Runtime.ConsistentRing.ConsistentRingProvider.membershipRingList">
            list of silo members sorted by the hash value of their address
        </member>
        <member name="M:Orleans.Runtime.ConsistentRing.ConsistentRingProvider.GetPrimaryTargetSilo(System.UInt32)">
            <summary>
            Returns the silo that this silo thinks is the primary owner of the key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.ConsistentRing.ConsistentRingProvider.GetMySucessors(System.Int32)">
            <summary>
            Returns null if silo is not in the list of members
            </summary>
        </member>
        <member name="M:Orleans.Runtime.ConsistentRing.ConsistentRingProvider.GetMyPredecessors(System.Int32)">
            <summary>
            Returns null if silo is not in the list of members
            </summary>
        </member>
        <member name="M:Orleans.Runtime.ConsistentRing.ConsistentRingProvider.FindPredecessors(Orleans.Runtime.SiloAddress,System.Int32)">
            <summary>
            Returns null if silo is not in the list of members
            </summary>
        </member>
        <member name="M:Orleans.Runtime.ConsistentRing.ConsistentRingProvider.FindSuccessors(Orleans.Runtime.SiloAddress,System.Int32)">
            <summary>
            Returns null if silo is not in the list of members
            </summary>
        </member>
        <member name="M:Orleans.Runtime.ConsistentRing.ConsistentRingProvider.CalculateTargetSilo(System.UInt32,System.Boolean)">
            <summary>
            Finds the silo that owns the given hash value.
            This routine will always return a non-null silo address unless the excludeThisSiloIfStopping parameter is true,
            this is the only silo known, and this silo is stopping.
            </summary>
            <param name="hash"></param>
            <param name="excludeThisSiloIfStopping"></param>
            <returns></returns>
        </member>
        <member name="T:Orleans.Runtime.ConsistentRing.VirtualBucketsRingProvider">
            <summary>
            We use the 'backward/clockwise' definition to assign responsibilities on the ring. 
            E.g. in a ring of nodes {5, 10, 15} the responsible for key 7 is 10 (the node is responsible for its predecessing range). 
            The backwards/clockwise approach is consistent with many overlays, e.g., Chord, Cassandra, etc.
            Note: MembershipOracle uses 'forward/counter-clockwise' definition to assign responsibilities. 
            E.g. in a ring of nodes {5, 10, 15}, the responsible of key 7 is node 5 (the node is responsible for its sucessing range)..
            </summary>
        </member>
        <member name="M:Orleans.Runtime.ConsistentRing.VirtualBucketsRingProvider.CalculateTargetSilo(System.UInt32,System.Boolean)">
            <summary>
            Finds the silo that owns the given hash value.
            This routine will always return a non-null silo address unless the excludeThisSiloIfStopping parameter is true,
            this is the only silo known, and this silo is stopping.
            </summary>
            <param name="hash"></param>
            <param name="excludeThisSiloIfStopping"></param>
            <returns></returns>
        </member>
        <member name="T:Orleans.Runtime.IHealthCheckParticipant">
            <summary>
            Interface for health check participants.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.IHealthCheckParticipant.CheckHealth(System.DateTime)">
            <summary>
            Returns a value indicating the health of this instance.
            </summary>
            <param name="lastCheckTime">The last time which this participant's health was checked.</param>
            <returns><see langword="true"/> if the participant is healthy, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="T:Orleans.Runtime.IMembershipOracle">
            <summary>
            Authoritative source for cluster membership.
            </summary>
        </member>
        <member name="T:Orleans.Runtime.LogConsistency.ProtocolServices">
            <summary>
            Functionality for use by log view adaptors that run distributed protocols. 
            This class allows access to these services to providers that cannot see runtime-internals.
            It also stores grain-specific information like the grain reference, and caches 
            </summary>
        </member>
        <member name="P:Orleans.Runtime.LogConsistency.ProtocolServices.SerializationManager">
            <inheritdoc />
        </member>
        <member name="M:Orleans.Runtime.LogConsistency.LogConsistencyProviderManager.GetProviderNames">
            <summary>
            Get list of providers loaded in this silo.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Orleans.Runtime.Scheduler.ActivationTaskScheduler">
            <summary>
            A single-concurrency, in-order task scheduler for per-activation work scheduling.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Scheduler.ActivationTaskScheduler.GetScheduledTasks">
            <summary>Gets an enumerable of the tasks currently scheduled on this scheduler.</summary>
            <returns>An enumerable of the tasks currently scheduled.</returns>
        </member>
        <member name="M:Orleans.Runtime.Scheduler.ActivationTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>Queues a task to the scheduler.</summary>
            <param name="task">The task to be queued.</param>
        </member>
        <member name="M:Orleans.Runtime.Scheduler.ActivationTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            Determines whether the provided <see cref="T:System.Threading.Tasks.Task"/> can be executed synchronously in this call, and if it can, executes it.
            </summary>
            <returns>
            A Boolean value indicating whether the task was executed inline.
            </returns>
            <param name="task">The <see cref="T:System.Threading.Tasks.Task"/> to be executed.</param>
            <param name="taskWasPreviouslyQueued">A Boolean denoting whether or not task has previously been queued. If this parameter is True, then the task may have been previously queued (scheduled); if False, then the task is known not to have been queued, and this call is being made in order to execute the task inline without queuing it.</param>
        </member>
        <member name="M:Orleans.Runtime.Scheduler.OrleansTaskScheduler.RunTask(System.Threading.Tasks.Task)">
            <summary>
            Run the specified task synchronously on the current thread
            </summary>
            <param name="task"><c>Task</c> to be executed</param>
        </member>
        <member name="M:Orleans.Runtime.Scheduler.SchedulerExtensions.RunOrQueueAction(Orleans.Runtime.Scheduler.OrleansTaskScheduler,System.Action,Orleans.Runtime.ISchedulingContext)">
            <summary>
            Execute a closure ensuring that it has a runtime context (e.g. to send messages from an arbitrary thread)
            </summary>
            <param name="scheduler"></param>
            <param name="action"></param>
            <param name="targetContext"></param>
        </member>
        <member name="M:Orleans.Runtime.Scheduler.TaskWorkItem.#ctor(Orleans.Runtime.Scheduler.ITaskScheduler,System.Threading.Tasks.Task,Orleans.Runtime.ISchedulingContext)">
            <summary>
            Create a new TaskWorkItem for running the specified Task on the specified scheduler.
            </summary>
            <param name="sched">Scheduler to execute this Task action. A value of null means use the Orleans system scheduler.</param>
            <param name="t">Task to be performed</param>
            <param name="context">Execution context</param>
        </member>
        <member name="M:Orleans.Runtime.Scheduler.WorkItemGroup.EnqueueTask(System.Threading.Tasks.Task)">
            <summary>
            Adds a task to this activation.
            If we're adding it to the run list and we used to be waiting, now we're runnable.
            </summary>
            <param name="task">The work item to add.</param>
        </member>
        <member name="M:Orleans.Runtime.Scheduler.WorkItemGroup.Stop">
            <summary>
            Shuts down this work item group so that it will not process any additional work items, even if they
            have already been queued.
            </summary>
        </member>
        <member name="T:Orleans.Runtime.Host.SiloHost">
            <summary>
            Allows programmatically hosting an Orleans silo in the curent app domain.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.Host.SiloHost.Name">
            <summary> Name of this silo. </summary>
        </member>
        <member name="P:Orleans.Runtime.Host.SiloHost.Type">
            <summary> Type of this silo - either <c>Primary</c> or <c>Secondary</c>. </summary>
        </member>
        <member name="P:Orleans.Runtime.Host.SiloHost.ConfigFileName">
            <summary>
            Configuration file used for this silo.
            Changing this after the silo has started (when <c>ConfigLoaded == true</c>) will have no effect.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.Host.SiloHost.TraceFilePath">
            <summary>
            Directory to use for the trace log file written by this silo.
            </summary>
            <remarks>
            <para>
            The values of <c>null</c> or <c>"None"</c> mean no log file will be written by Orleans Logger manager.
            </para>
            <para>
            When deciding The values of <c>null</c> or <c>"None"</c> mean no log file will be written by Orleans Logger manager.
            </para>
            </remarks>
        </member>
        <member name="P:Orleans.Runtime.Host.SiloHost.Config">
            <summary> Configuration data for the Orleans system. </summary>
        </member>
        <member name="P:Orleans.Runtime.Host.SiloHost.NodeConfig">
            <summary> Configuration data for this silo. </summary>
        </member>
        <member name="P:Orleans.Runtime.Host.SiloHost.Debug">
            <summary> 
            Silo Debug flag. 
            If set to <c>true</c> then additional diagnostic info will be written during silo startup.
             </summary>
        </member>
        <member name="P:Orleans.Runtime.Host.SiloHost.ConfigLoaded">
            <summary>
            Whether the silo config has been loaded and initializing it's runtime config.
            </summary>
            <remarks>
            Changes to silo config properties will be ignored after <c>ConfigLoaded == true</c>.
            </remarks>
        </member>
        <member name="P:Orleans.Runtime.Host.SiloHost.DeploymentId">
            <summary> Deployment Id (if any) for the cluster this silo is running in. </summary>
        </member>
        <member name="P:Orleans.Runtime.Host.SiloHost.Verbose">
            <summary>
            Verbose flag. 
            If set to <c>true</c> then additional status and diagnostics info will be written during silo startup.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.Host.SiloHost.IsStarted">
            <summary> Whether this silo started successfully and is currently running. </summary>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="siloName">Name of this silo.</param>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.#ctor(System.String,Orleans.Runtime.Configuration.ClusterConfiguration)">
            <summary> Constructor </summary>
            <param name="siloName">Name of this silo.</param>
            <param name="config">Silo config that will be used to initialize this silo.</param>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.#ctor(System.String,System.IO.FileInfo)">
            <summary> Constructor </summary>
            <param name="siloName">Name of this silo.</param>
            <param name="configFile">Silo config file that will be used to initialize this silo.</param>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.InitializeOrleansSilo">
            <summary>
            Initialize this silo.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.UnInitializeOrleansSilo">
            <summary>
            Uninitialize this silo.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.StartOrleansSilo(System.Boolean)">
            <summary>
            Start this silo.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.StopOrleansSilo">
            <summary>
            Stop this silo.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.ShutdownOrleansSilo">
            <summary>
            Gracefully shutdown this silo.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.WaitForOrleansSiloShutdown">
            <summary>
            Wait for this silo to shutdown.
            </summary>
            <remarks>
            Note: This method call will block execution of current thread, 
            and will not return control back to the caller until the silo is shutdown.
            </remarks>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.WaitForOrleansSiloShutdown(System.Threading.CancellationToken)">
            <summary>
            Wait for this silo to shutdown or to be stopped with provided cancellation token.
            </summary>
            <param name="cancellationToken">Cancellation token.</param>
            <remarks>
            Note: This method call will block execution of current thread, 
            and will not return control back to the caller until the silo is shutdown or 
            an external request for cancellation has been issued.
            </remarks>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.SetDeploymentId(System.String,System.String)">
            <summary>
            Set the DeploymentId for this silo, 
            as well as the connection string to use the silo system data, 
            such as the cluster membership table..
            </summary>
            <param name="deploymentId">DeploymentId this silo is part of.</param>
            <param name="connectionString">Azure connection string to use the silo system data.</param>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.SetSiloEndpoint(System.Net.IPEndPoint,System.Int32)">
            <summary>
            Set the main endpoint address for this silo,
            plus the silo generation value to be used to distinguish this silo instance
            from any previous silo instances previously running on this endpoint.
            </summary>
            <param name="endpoint">IP address and port of the main inter-silo socket connection.</param>
            <param name="generation">Generation number for this silo.</param>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.SetProxyEndpoint(System.Net.IPEndPoint)">
            <summary>
            Set the gateway proxy endpoint address for this silo.
            </summary>
            <param name="endpoint">IP address of the gateway socket connection.</param>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.SetSeedNodeEndpoint(System.Net.IPEndPoint)">
            <summary>
            Set the seed node endpoint address to be used by silo.
            </summary>
            <param name="endpoint">IP address of the inter-silo connection socket on the seed node silo.</param>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.SetSeedNodeEndpoints(System.Net.IPEndPoint[])">
            <summary>
            Set the set of seed node endpoint addresses to be used by silo.
            </summary>
            <param name="endpoints">IP addresses of the inter-silo connection socket on the seed node silos.</param>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.SetPrimaryNodeEndpoint(System.Net.IPEndPoint)">
            <summary>
            Set the endpoint addresses for the Primary silo (if any).
            This silo may be Primary, in which case this address should match 
            this silo's inter-silo connection socket address.
            </summary>
            <param name="endpoint">The IP address for the inter-silo connection socket on the Primary silo.</param>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.SetSiloType(Orleans.Runtime.Silo.SiloType)">
            <summary>
            Set the type of this silo. Default is Secondary.
            </summary>
            <param name="siloType">Type of this silo.</param>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.SetSiloLivenessType(Orleans.Runtime.Configuration.GlobalConfiguration.LivenessProviderType)">
            <summary>
             Set the membership liveness type to be used by this silo.
            </summary>
            <param name="livenessType">Liveness type for this silo</param>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.SetReminderServiceType(Orleans.Runtime.Configuration.GlobalConfiguration.ReminderServiceProviderType)">
            <summary>
             Set the reminder service type to be used by this silo.
            </summary>
            <param name="reminderType">Reminder service type for this silo</param>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.SetExpectedClusterSize(System.Int32)">
            <summary>
            Set expected deployment size.
            </summary>
            <param name="size">The expected deployment size.</param>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.ReportStartupError(System.Exception)">
            <summary>
            Report an error during silo startup.
            </summary>
            <remarks>
            Information on the silo startup issue will be logged to any attached Loggers,
            then a timestamped StartupError text file will be written to 
            the current working directory (if possible).
            </remarks>
            <param name="exc">Exception which caused the silo startup issue.</param>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.LoadOrleansConfig">
            <summary>
            Search for and load the config file for this silo.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.SetSiloConfig(Orleans.Runtime.Configuration.ClusterConfiguration)">
            <summary>
            Allows silo config to be programmatically set.
            </summary>
            <param name="config">Configuration data for this silo and cluster.</param>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.WaitForOrleansSiloShutdownImpl(System.Nullable{System.Threading.CancellationToken})">
            <summary>
            Helper to wait for this silo to shutdown or to be stopped via a cancellation token.
            </summary>
            <param name="cancellationToken">Optional cancellation token.</param>
            <remarks>
            Note: This method call will block execution of current thread, 
            and will not return control back to the caller until the silo is shutdown or 
            an external request for cancellation has been issued.
            </remarks>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.HandleExternalCancellation">
            <summary>
            Handle the silo stop request coming from an external cancellation token.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.Dispose">
            <summary>
            Called when this silo is being Disposed by .NET runtime.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Host.SiloHost.Dispose(System.Boolean)">
            <summary> Perform the Dispose / cleanup operation. </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:Orleans.Runtime.Providers.SiloProviderRuntime.ExecutingEntityIdentity">
            <inheritdoc />
        </member>
        <member name="M:Orleans.Runtime.Providers.SiloProviderRuntime.GetStreamDirectory">
            <inheritdoc />
        </member>
        <member name="M:Orleans.Runtime.Providers.SiloProviderRuntime.BindExtension``2(System.Func{``0})">
            <inheritdoc />
        </member>
        <member name="T:Orleans.Runtime.DeploymentLoadPublisher">
            <summary>
            This class collects runtime statistics for all silos in the current deployment for use by placement.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.AssemblyLoaderUtils.AssemblyResolveTracer(System.Object,System.ResolveEventArgs)">
            <see cref="T:System.ResolveEventHandler"/>
        </member>
        <member name="M:Orleans.Runtime.AssemblyLoaderUtils.AssemblyLoadTracer(System.Object,System.AssemblyLoadEventArgs)">
            <see cref="T:System.AssemblyLoadEventHandler"/>
        </member>
        <member name="T:Orleans.Runtime.AssemblyLoaderUtils.AssemblyLoadLogEntry">
            <see cref="T:System.ResolveEventHandler"/>
        </member>
        <member name="P:Orleans.Runtime.AssemblyLoaderUtils.AssemblyLoadLogEntry.AssemblyName">
            <summary>
            The name of the item to resolve.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.AssemblyLoaderUtils.AssemblyLoadRequestDetails.RequestingAssembly">
            <summary>
            Gets the assembly whose dependency is being resolved.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.AssemblyLoaderUtils.AssemblyLoadCompleteDetails.AssemblyLocation">
            <summary>
            Gets the assembly which has just been loaded from.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.GrainTypeManager.GetGrainTypeList">
            <summary>
            Returns a list of all graintypes in the system.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Orleans.Runtime.ActivationCollector">
            <summary>
            Identifies activations that have been idle long enough to be deactivated.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.ActivationCollector.ScanStale">
            <summary>
            Scans for activations that are due for collection.
            </summary>
            <returns>A list of activations that are due for collection.</returns>
        </member>
        <member name="M:Orleans.Runtime.ActivationCollector.ScanAll(System.TimeSpan)">
            <summary>
            Scans for activations that have been idle for the specified age limit.
            </summary>
            <param name="ageLimit">The age limit.</param>
            <returns></returns>
        </member>
        <member name="T:Orleans.Runtime.Management.ManagementGrain">
            <summary>
            Implementation class for the Orleans management grain.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Management.ManagementGrain.PerformPerSiloAction(Orleans.Runtime.SiloAddress[],System.Func{Orleans.Runtime.SiloAddress,System.Threading.Tasks.Task})">
            <summary>
            Perform an action for each silo.
            </summary>
            <remarks>
            Because SiloControl contains a reference to a system target, each method call using that reference 
            will get routed either locally or remotely to the appropriate silo instance auto-magically.
            </remarks>
            <param name="siloAddresses">List of silos to perform the action for</param>
            <param name="perSiloAction">The action functiona to be performed for each silo</param>
            <returns>Array containing one Task for each silo the action was performed for</returns>
        </member>
        <member name="M:Orleans.Runtime.Storage.StorageProviderManager.GetProviderNames">
            <summary>
            Get list of providers loaded in this silo.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Orleans.Runtime.SystemTarget">
            <summary>
            Base class for various system services, such as grain directory, reminder service, etc.
            Made public for GrainSerive to inherit from it.
            Can be turned to internal after a refactoring that would remove the inheritance relation.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.SystemTarget.Silo">
            <summary>Silo address of the system target.</summary>
        </member>
        <member name="M:Orleans.Runtime.SystemTarget.#ctor">
            <summary>Only needed to make Reflection happy.</summary>
        </member>
        <member name="M:Orleans.Runtime.SystemTarget.RegisterTimer(System.Func{System.Object,System.Threading.Tasks.Task},System.Object,System.TimeSpan,System.TimeSpan,System.String)">
            <summary>
            Register a timer to send regular callbacks to this grain.
            This timer will keep the current grain from being deactivated.
            </summary>
            <param name="asyncCallback"></param>
            <param name="state"></param>
            <param name="dueTime"></param>
            <param name="period"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.SystemTarget.ToString">
            <summary>Override of object.ToString()</summary>
        </member>
        <member name="M:Orleans.Runtime.SystemTarget.ToDetailedString">
            <summary>Adds details about message currently being processed</summary>
        </member>
        <member name="M:Orleans.Runtime.ActivationDirectory.FindTargets(Orleans.Runtime.GrainId)">
            <summary>
            Returns null if no activations exist for this grain ID, rather than an empty list
            </summary>
        </member>
        <member name="M:Orleans.Runtime.SiloAssemblyLoader.GetTypeData(System.Type,System.Type)">
            <summary>
            Get type data for the given grain type
            </summary>
        </member>
        <member name="T:Orleans.Runtime.GrainTypeData">
            <summary>
            Grain type meta data
            </summary>
        </member>
        <member name="M:Orleans.Runtime.GrainTypeData.GetRemoteInterfaces(System.Type)">
            <summary>
            Returns a list of remote interfaces implemented by a grain class or a system target
            </summary>
            <param name="grainType">Grain or system target class</param>
            <returns>List of remote interfaces implemented by grainType</returns>
        </member>
        <member name="M:Orleans.Runtime.GrainTypeData.GetMayInterleavePredicate(System.Reflection.TypeInfo)">
            <summary>
            Returns interleave predicate depending on whether class is marked with <see cref="T:Orleans.Concurrency.MayInterleaveAttribute"/> or not.
            </summary>
            <param name="grainType">Grain class.</param>
            <returns></returns>
        </member>
        <member name="T:Orleans.Runtime.Silo">
            <summary>
            Orleans silo.
            </summary>
        </member>
        <member name="F:Orleans.Runtime.Silo.PrimarySiloName">
            <summary> Standard name for Primary silo. </summary>
        </member>
        <member name="T:Orleans.Runtime.Silo.SiloType">
            <summary> Silo Types. </summary>
        </member>
        <member name="F:Orleans.Runtime.Silo.SiloType.None">
            <summary> No silo type specified. </summary>
        </member>
        <member name="F:Orleans.Runtime.Silo.SiloType.Primary">
            <summary> Primary silo. </summary>
        </member>
        <member name="F:Orleans.Runtime.Silo.SiloType.Secondary">
            <summary> Secondary silo. </summary>
        </member>
        <member name="P:Orleans.Runtime.Silo.Type">
            <summary>
            Gets the type of this 
            </summary>
        </member>
        <member name="P:Orleans.Runtime.Silo.SiloAddress">
            <summary> SiloAddress for this silo. </summary>
        </member>
        <member name="P:Orleans.Runtime.Silo.SiloTerminatedEvent">
            <summary>
             Silo termination event used to signal shutdown of this silo.
            </summary>
        </member>
        <member name="F:Orleans.Runtime.Silo.testHook">
            <summary>
            Test hook connection for white-box testing of silo.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Silo.#ctor(System.String,Orleans.Runtime.Silo.SiloType,Orleans.Runtime.Configuration.ClusterConfiguration)">
            <summary>
            Initializes a new instance of the <see cref="T:Orleans.Runtime.Silo"/> class.
            </summary>
            <param name="name">Name of this silo.</param>
            <param name="siloType">Type of this silo.</param>
            <param name="config">Silo config data to be used for this silo.</param>
        </member>
        <member name="M:Orleans.Runtime.Silo.#ctor(Orleans.Runtime.SiloInitializationParameters)">
            <summary>
            Initializes a new instance of the <see cref="T:Orleans.Runtime.Silo"/> class.
            </summary>
            <param name="initializationParams">
            The silo initialization parameters.
            </param>
        </member>
        <member name="M:Orleans.Runtime.Silo.Start">
            <summary> Perform silo startup operations. </summary>
        </member>
        <member name="M:Orleans.Runtime.Silo.UpdateStreamProviders(System.Collections.Generic.IDictionary{System.String,Orleans.Runtime.Configuration.ProviderCategoryConfiguration})">
            <summary>
            Load and initialize newly added stream providers. Remove providers that are not on the list that's being passed in.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Silo.Stop">
            <summary>
            Gracefully stop the run time system only, but not the application. 
            Applications requests would be abruptly terminated, while the internal system state gracefully stopped and saved as much as possible.
            Grains are not deactivated.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Silo.Shutdown">
            <summary>
            Gracefully stop the run time system and the application. 
            All grains will be properly deactivated.
            All in-flight applications requests would be awaited and finished gracefully.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Silo.Terminate(System.Boolean)">
            <summary>
            Gracefully stop the run time system only, but not the application. 
            Applications requests would be abruptly terminated, while the internal system state gracefully stopped and saved as much as possible.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Silo.FastKill">
            <summary>
            Ungracefully stop the run time system and the application running on it. 
            Applications requests would be abruptly terminated, and the internal system state quickly stopped with minimal cleanup.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Silo.GetDebugDump(System.Boolean)">
            <summary> Return dump of diagnostic data from this silo. </summary>
            <param name="all"></param>
            <returns>Debug data for this silo.</returns>
        </member>
        <member name="M:Orleans.Runtime.Silo.ToString">
            <summary> Object.ToString override -- summary info for this silo. </summary>
        </member>
        <member name="P:Orleans.Runtime.Catalog.Dispatcher">
            <summary>
            Gets the dispatcher used by this instance.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Catalog.RegisterMessageTarget(Orleans.Runtime.ActivationData)">
            <summary>
            Register a new object to which messages can be delivered with the local lookup table and scheduler.
            </summary>
            <param name="activation"></param>
        </member>
        <member name="M:Orleans.Runtime.Catalog.UnregisterMessageTarget(Orleans.Runtime.ActivationData)">
            <summary>
            Unregister message target and stop delivering messages to it
            </summary>
            <param name="activation"></param>
        </member>
        <member name="M:Orleans.Runtime.Catalog.UnregisterGrainForTesting(Orleans.Runtime.GrainId)">
            <summary>
            FOR TESTING PURPOSES ONLY!!
            </summary>
            <param name="grain"></param>
        </member>
        <member name="M:Orleans.Runtime.Catalog.GetOrCreateActivation(Orleans.Runtime.ActivationAddress,System.Boolean,System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.Object},System.Threading.Tasks.Task@)">
            <summary>
            If activation already exists, use it
            Otherwise, create an activation of an existing grain by reading its state.
            Return immediately using a dummy that will queue messages.
            Concurrently start creating and initializing the real activation and replace it when it is ready.
            </summary>
            <param name="address">Grain's activation address</param>
            <param name="newPlacement">Creation of new activation was requested by the placement director.</param>
            <param name="grainType">The type of grain to be activated or created</param>
            <param name="genericArguments">Specific generic type of grain to be activated or created</param>
            <param name="requestContextData">Request context data.</param>
            <param name="activatedPromise"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.Catalog.RecoverFailedInitActivation(Orleans.Runtime.ActivationData,Orleans.Runtime.Catalog.ActivationInitializationStage,Orleans.Runtime.Catalog.ActivationRegistrationResult,System.Exception)">
            <summary>
            Recover from a failed attempt to initialize a new activation.
            </summary>
            <param name="activation">The activation which failed to be initialized.</param>
            <param name="initStage">The initialization stage at which initialization failed.</param>
            <param name="registrationResult">The result of registering the activation with the grain directory.</param>
            <param name="exception">The exception, if present, for logging purposes.</param>
        </member>
        <member name="M:Orleans.Runtime.Catalog.CreateGrainInstance(System.String,Orleans.Runtime.ActivationData,System.String)">
            <summary>
            Perform just the prompt, local part of creating an activation object
            Caller is responsible for registering locally, registering with store and calling its activate routine
            </summary>
            <param name="grainTypeName"></param>
            <param name="data"></param>
            <param name="genericArguments"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.Catalog.TryGetActivationData(Orleans.Runtime.ActivationId,Orleans.Runtime.ActivationData@)">
            <summary>
            Try to get runtime data for an activation
            </summary>
            <param name="activationId"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.Catalog.DeactivateActivations(System.Collections.Generic.List{Orleans.Runtime.ActivationData})">
            <summary>
            Gracefully deletes activations, putting it into a shutdown state to
            complete and commit outstanding transactions before deleting it.
            To be called not from within Activation context, so can be awaited.
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.Catalog.DestroyActivationVoid(Orleans.Runtime.ActivationData)">
            <summary>
            Deletes activation immediately regardless of active transactions etc.
            For use by grain delete, transaction abort, etc.
            </summary>
            <param name="activation"></param>
        </member>
        <member name="M:Orleans.Runtime.Catalog.DestroyActivations(System.Collections.Generic.List{Orleans.Runtime.ActivationData})">
            <summary>
            Forcibly deletes activations now, without waiting for any outstanding transactions to complete.
            Deletes activation immediately regardless of active transactions etc.
            For use by grain delete, transaction abort, etc.
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="T:Orleans.Runtime.Catalog.ActivationRegistrationResult">
            <summary>
            Represents the results of an attempt to register an activation.
            </summary>
        </member>
        <member name="F:Orleans.Runtime.Catalog.ActivationRegistrationResult.Success">
            <summary>
            Represents a successful activation.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.Catalog.ActivationRegistrationResult.IsSuccess">
            <summary>
            Returns true if this instance represents a successful registration, false otheriwse.
            </summary>
        </member>
        <member name="P:Orleans.Runtime.Catalog.ActivationRegistrationResult.ExistingActivationAddress">
            <summary>
            The existing activation address if this instance represents a duplicate activation.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Catalog.InvokeActivate(Orleans.Runtime.ActivationData,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Invoke the activate method on a newly created activation
            </summary>
            <param name="activation"></param>
            <param name="requestContextData"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.Dispatcher.ReceiveMessage(Orleans.Runtime.Message)">
            <summary>
            Receive a new message:
            - validate order constraints, queue (or possibly redirect) if out of order
            - validate transactions constraints
            - invoke handler if ready, otherwise enqueue for later invocation
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Orleans.Runtime.Dispatcher.ReceiveRequest(Orleans.Runtime.Message,Orleans.Runtime.ActivationData)">
            <summary>
            Check if we can locally accept this message.
            Redirects if it can't be accepted.
            </summary>
            <param name="message"></param>
            <param name="targetActivation"></param>
        </member>
        <member name="M:Orleans.Runtime.Dispatcher.ActivationMayAcceptRequest(Orleans.Runtime.ActivationData,Orleans.Runtime.Message)">
            <summary>
            Determine if the activation is able to currently accept the given message
            - always accept responses
            For other messages, require that:
            - activation is properly initialized
            - the message would not cause a reentrancy conflict
            </summary>
            <param name="targetActivation"></param>
            <param name="incoming"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.Dispatcher.CanInterleave(Orleans.Runtime.ActivationData,Orleans.Runtime.Message)">
            <summary>
            Whether an incoming message can interleave 
            </summary>
            <param name="targetActivation"></param>
            <param name="incoming"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Runtime.Dispatcher.CheckDeadlock(Orleans.Runtime.Message)">
            <summary>
            Check if the current message will cause deadlock.
            Throw DeadlockException if yes.
            </summary>
            <param name="message">Message to analyze</param>
        </member>
        <member name="M:Orleans.Runtime.Dispatcher.HandleIncomingRequest(Orleans.Runtime.Message,Orleans.Runtime.ActivationData)">
            <summary>
            Handle an incoming message and queue/invoke appropriate handler
            </summary>
            <param name="message"></param>
            <param name="targetActivation"></param>
        </member>
        <member name="M:Orleans.Runtime.Dispatcher.EnqueueRequest(Orleans.Runtime.Message,Orleans.Runtime.ActivationData)">
            <summary>
            Enqueue message for local handling after transaction completes
            </summary>
            <param name="message"></param>
            <param name="targetActivation"></param>
        </member>
        <member name="M:Orleans.Runtime.Dispatcher.RerouteMessage(Orleans.Runtime.Message)">
            <summary>
            Reroute a message coming in through a gateway
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Orleans.Runtime.Dispatcher.AsyncSendMessage(Orleans.Runtime.Message,Orleans.Runtime.ActivationData)">
            <summary>
            Send an outgoing message
            - may buffer for transaction completion / commit if it ends a transaction
            - choose target placement address, maintaining send order
            - add ordering info and maintain send order
            
            </summary>
            <param name="message"></param>
            <param name="sendingActivation"></param>
        </member>
        <member name="M:Orleans.Runtime.Dispatcher.AddressMessage(Orleans.Runtime.Message)">
            <summary>
            Resolve target address for a message
            - use transaction info
            - check ordering info in message and sending activation
            - use sender's placement strategy
            </summary>
            <param name="message"></param>
            <returns>Resolve when message is addressed (modifies message fields)</returns>
        </member>
        <member name="M:Orleans.Runtime.Dispatcher.TransportMessage(Orleans.Runtime.Message)">
            <summary>
            Directly send a message to the transport without processing
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Orleans.Runtime.Dispatcher.OnActivationCompletedRequest(Orleans.Runtime.ActivationData,Orleans.Runtime.Message)">
            <summary>
            Invoked when an activation has finished a transaction and may be ready for additional transactions
            </summary>
            <param name="activation">The activation that has just completed processing this message</param>
            <param name="message">The message that has just completed processing. 
            This will be <c>null</c> for the case of completion of Activate/Deactivate calls.</param>
        </member>
        <member name="T:Orleans.Runtime.InsideRuntimeClient">
            <summary>
            Internal class for system grains to get access to runtime object
            </summary>
        </member>
        <member name="P:Orleans.Runtime.InsideRuntimeClient.ClientInvokeCallback">
            <inheritdoc />
        </member>
        <member name="M:Orleans.Runtime.InsideRuntimeClient.UnRegisterCallback(Orleans.Runtime.CorrelationId)">
            <summary>
            UnRegister a callback.
            </summary>
            <param name="id"></param>
        </member>
        <member name="T:Orleans.Runtime.StreamProviderManagerAgent">
            <summary>
            System target that specifically handles runtime adding/removing stream providers.
            </summary>
        </member>
        <member name="T:Orleans.Runtime.Utilities.FactoryUtility">
            <summary>
            Utility methods for creating factories which construct instances of objects using an <see cref="T:System.IServiceProvider"/>.
            </summary>
        </member>
        <member name="M:Orleans.Runtime.Utilities.FactoryUtility.Create``1(System.IServiceProvider)">
            <summary>
            Creates a factory returning a new <typeparamref name="TInstance"/>.
            </summary>
            <typeparam name="TInstance">The instance type.</typeparam>
            <param name="serviceProvider">The service provider.</param>
            <returns>A new factory.</returns>
        </member>
        <member name="M:Orleans.Runtime.Utilities.FactoryUtility.Create``2(System.IServiceProvider)">
            <summary>
            Creates a factory returning a new <typeparamref name="TInstance"/> given an argument of type <typeparamref name="TParam1"/>.
            </summary>
            <typeparam name="TParam1">The type of the parameter to the factory.</typeparam>
            <typeparam name="TInstance">The instance type.</typeparam>
            <param name="serviceProvider">The service provider.</param>
            <returns>A new factory.</returns>
        </member>
        <member name="M:Orleans.Runtime.Utilities.FactoryUtility.Create``3(System.IServiceProvider)">
            <summary>
            Creates a factory returning a new <typeparamref name="TInstance"/> given arguments of the specified types.
            </summary>
            <typeparam name="TParam1">The type of the 1st parameter to the factory.</typeparam>
            <typeparam name="TParam2">The type of the 2nd parameter to the factory.</typeparam>
            <typeparam name="TInstance">The instance type.</typeparam>
            <param name="serviceProvider">The service provider.</param>
            <returns>A new factory.</returns>
        </member>
        <member name="M:Orleans.Runtime.Utilities.FactoryUtility.Create``4(System.IServiceProvider)">
            <summary>
            Creates a factory returning a new <typeparamref name="TInstance"/> given arguments of the specified types.
            </summary>
            <typeparam name="TParam1">The type of the 1st parameter to the factory.</typeparam>
            <typeparam name="TParam2">The type of the 2nd parameter to the factory.</typeparam>
            <typeparam name="TParam3">The type of the 3rd parameter to the factory.</typeparam>
            <typeparam name="TInstance">The instance type.</typeparam>
            <param name="serviceProvider">The service provider.</param>
            <returns>A new factory.</returns>
        </member>
        <member name="T:Orleans.Streams.StreamQueueBalancerType">
            <summary>
            Built-in stream queue balancer type which is supported natively in orleans
            </summary>
        </member>
        <member name="F:Orleans.Streams.StreamQueueBalancerType.ConsistentRingBalancer">
            <summary>
            Stream queue balancer that uses consistent ring provider for load balancing
            </summary>
        </member>
        <member name="F:Orleans.Streams.StreamQueueBalancerType.DynamicAzureDeploymentBalancer">
            <summary>
            Stream queue balancer that uses Azure deployment information and silo statuses from Membership oracle for load balancing.  
            Requires silo running in Azure.
            This Balancer uses both the information about the full set of silos as reported by Azure role code and 
            the information from Membership oracle about currently active (alive) silos and rebalances queues from non active silos.
            </summary>
        </member>
        <member name="F:Orleans.Streams.StreamQueueBalancerType.StaticAzureDeploymentBalancer">
            <summary>
            Stream queue balancer that uses Azure deployment information for load balancing. 
            Requires silo running in Azure.
            This Balancer uses both the information about the full set of silos as reported by Azure role code but 
            does NOT use the information from Membership oracle about currently alive silos. 
            That is, it does not rebalance queues based on dymanic changes in the cluster Membership.
            </summary>
        </member>
        <member name="F:Orleans.Streams.StreamQueueBalancerType.DynamicClusterConfigDeploymentBalancer">
            <summary>
            Stream queue balancer that uses the cluster configuration to determine deployment information for load balancing.  
            It does not support dynamic changes to global (full) cluster configuration.
            This Balancer does use the information from Membership oracle about currently active (alive) silos 
            and rebalances queues from non active silos.
            </summary>
        </member>
        <member name="F:Orleans.Streams.StreamQueueBalancerType.StaticClusterConfigDeploymentBalancer">
            <summary>
            Stream queue balancer that uses the cluster configuration to determine deployment information for load balancing.  
            It does not support dynamic changes to global (full) cluster configuration.
            This Balancer does NOT use the information from Membership oracle about currently active silos.
            That is, it does not rebalance queues based on dymanic changes in the cluster Membership.
            </summary>
        </member>
        <member name="T:Orleans.Streams.LoadShedQueueFlowController">
            <summary>
            Flow control triggered by silo load shedding.
            All or nothing trigger.  Will request maxint, or 0.
            </summary>
        </member>
        <member name="F:Orleans.Streams.LoadShedQueueFlowController.DefaultPercentOfLoadSheddingLimit">
            <summary>
            Default percentage of silo load shedding limit.
            </summary>
        </member>
        <member name="M:Orleans.Streams.LoadShedQueueFlowController.CreateAsPercentOfLoadSheddingLimit(System.Func{Orleans.Runtime.Configuration.NodeConfiguration},System.Int32)">
            <summary>
            Creates a flow controller triggered when the CPU reaches a percentage of the cluster load shedding limit.
            This is intended to reduce queue read rate prior to causing the silo to shed load.
            Note:  Triggered only when load shedding is enabled.
            </summary>
            <param name="getNodeConfig">The method used to get the current node configuration.</param>
            <param name="percentOfSiloSheddingLimit">Percentage of load shed limit which triggers a reduction of queue read rate.</param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Streams.LoadShedQueueFlowController.CreateAsPercentageOfCPU(System.Int32,System.Func{Orleans.Runtime.Configuration.NodeConfiguration})">
            <summary>
            Creates a flow controller triggered when the CPU reaches the specified limit.
            Note:  Triggered only when load shedding is enabled.
            </summary>
            <param name="loadSheddingLimit">Percentage of CPU which triggers queue read rate reduction</param>
            <param name="getNodeConfig">The method used to get the current node configuration.</param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Streams.LoadShedQueueFlowController.#ctor(System.Int32,System.Func{Orleans.Runtime.Configuration.NodeConfiguration})">
            <summary>
            Constructor
            </summary>
            <param name="loadSheddingLimit"></param>
            <param name="getNodeConfig">The method used to get the current node configuration.</param>
        </member>
        <member name="M:Orleans.Streams.LoadShedQueueFlowController.GetMaxAddCount">
            <summary>
            The limit of the maximum number of items that can be added
            </summary>
        </member>
        <member name="M:Orleans.Streams.PersistentStreamPullingManager.QueueDistributionChangeNotification">
            <summary>
            Actions to take when the queue distribution changes due to a failure or a join.
            Since this pulling manager is system target and queue distribution change notifications
            are delivered to it as grain method calls, notifications are not reentrant. To simplify
            notification handling we execute them serially, in a non-reentrant way.  We also supress
            and don't execute an older notification if a newer one was already delivered.
            </summary>
        </member>
        <member name="M:Orleans.Streams.PersistentStreamPullingManager.AddNewQueues(System.Collections.Generic.IEnumerable{Orleans.Streams.QueueId},System.Boolean)">
            <summary>
            Take responsibility for a set of new queues that were assigned to me via a new range.
            We first create one pulling agent for every new queue and store them in our internal data structure, then try to initialize the agents.
            ERROR HANDLING:
                The responsibility to handle initialization and shutdown failures is inside the Agents code.
                The manager will call Initialize once and log an error. It will not call initialize again and will assume initialization has succeeded.
                Same applies to shutdown.
            </summary>
            <param name="myQueues"></param>
            <param name="failOnInit"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Streams.PersistentStreamPullingAgent.Initialize(Orleans.Concurrency.Immutable{Orleans.Streams.IQueueAdapter},Orleans.Concurrency.Immutable{Orleans.Streams.IQueueAdapterCache},Orleans.Concurrency.Immutable{Orleans.Streams.IStreamFailureHandler})">
            <summary>
            Take responsibility for a new queues that was assigned to me via a new range.
            We first store the new queue in our internal data structure, try to initialize it and start a pumping timer.
            ERROR HANDLING:
                The resposibility to handle initializatoion and shutdown failures is inside the INewQueueAdapterReceiver code.
                The agent will call Initialize once and log an error. It will not call initiliaze again.
                The receiver itself may attempt later to recover from this error and do initialization again. 
                The agent will assume initialization has succeeded and will subsequently start calling pumping receive.
                Same applies to shutdown.
            </summary>
            <param name="qAdapter"></param>
            <param name="queueAdapterCache"></param>
            <param name="failureHandler"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Streams.PersistentStreamPullingAgent.ReadFromQueue(Orleans.Streams.QueueId,Orleans.Streams.IQueueAdapterReceiver,System.Int32)">
            <summary>
            Read from queue.
            Returns true, if data was read, false if it was not
            </summary>
            <param name="myQueueId"></param>
            <param name="rcvr"></param>
            <param name="maxCacheAddCount"></param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Streams.PubSubRendezvousGrain.TryClearState">
            <summary>
            Try clear state will only clear the state if there are no producers or consumers.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Orleans.Streams.BestFitBalancer`2">
            <summary>
            Best fit balancer keeps each active bucket responsible for its ideal set of resources, and redistributes 
            resources from inactive buckets evenly over active buckets.  If there are large numbers of inactive buckets,
            this can lead to quite a bit of shuffling of resources from inactive buckets as buckets come back online.
            Requirements:
            - Even distribution of resources across buckets
            - Must be consistent results for same inputs regardless of input order.
            - Minimize movement of resources when rebalancing from changes in active buckets.
            - Must be deterministic independent of previous distribution state.
            Algorithm:
            - On creation generate an ideal distribution of resources across all buckets, that is, each bucket has no more than 1 resource more
               than any other bucket.
            - When requesting new resource distribution for a list of active buckets:
                1) Initialize the new distribution of each active bucket with the ideal resources for that bucket.  This prevents
                   these resources from ever being assigned to another bucket unless a bucket becomes inactive.
                2) Build a list of inactive buckets.
                3) For each inactive bucket, add its ideal resource allocation to the list of resources to be reallocated.
                4) Order the active buckets by the number of resources allocated to each and begin assigning them more resources 
                   from the list of resources to be reallocated.
                    i) Continue iterating over the active buckets assigning resources until there are no more resources that need
                       reallocated.
            </summary>
            <typeparam name="TBucket">Type of bucket upon which resources will be distributed among</typeparam>
            <typeparam name="TResource">Type of resources being distributed</typeparam>
        </member>
        <member name="M:Orleans.Streams.BestFitBalancer`2.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Constructor.
            Initializes an ideal distribution to be used to aid in resource to bucket affinity.
            </summary>
            <param name="buckets">Buckets among which to destribute resources.</param>
            <param name="resources">Resources to be distributed.</param>
        </member>
        <member name="M:Orleans.Streams.BestFitBalancer`2.GetDistribution(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Gets a distribution for the active buckets. 
            Any active buckets keep their ideal distribution.  Resources from inactive buckets are redistributed evenly
            among the active buckets, starting with those with the fewest allocated resources.
            </summary>
            <param name="activeBuckets">currently active buckets</param>
            <returns></returns>
        </member>
        <member name="M:Orleans.Streams.BestFitBalancer`2.BuildIdealDistribution(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Distribute resources evenly among buckets in a deterministic way.
            - Must distribute resources evenly regardles off order of inputs.
            </summary>
            <param name="buckets">Buckets among which to destribute resources.</param>
            <param name="resources">Resources to be distributed.</param>
            <returns>Dictionary of resources evenly distributed among the buckets</returns>
        </member>
        <member name="T:Orleans.Streams.StaticClusterDeploymentConfiguration">
            <summary>
            Deployment configuration that reads from orleans cluster configuration
            </summary>
        </member>
        <member name="T:Orleans.Streams.DeploymentBasedQueueBalancer">
            <summary>
            DeploymentBasedQueueBalancer is a stream queue balancer that uses deployment information to
            help balance queue distribution.
            DeploymentBasedQueueBalancer uses the deployment configuration to determine how many silos
            to expect and uses a silo status oracle to determine which of the silos are available.  With
            this information it tries to balance the queues using a best fit resource balancing algorithm.
            </summary>
        </member>
        <member name="M:Orleans.Streams.DeploymentBasedQueueBalancer.SiloStatusChangeNotification(Orleans.Runtime.SiloAddress,Orleans.Runtime.SiloStatus)">
            <summary>
            Called when the status of a silo in the cluster changes.
            - Notify listeners
            </summary>
            <param name="updatedSilo">Silo which status has changed</param>
            <param name="status">new silo status</param>
        </member>
        <member name="M:Orleans.Streams.DeploymentBasedQueueBalancer.GetBalancer">
            <summary>
            Checks to see if deployment configuration has changed, by adding or removing silos.
            If so, it updates the list of all silo names and creates a new resource balancer.
            This should occure rarely.
            </summary>
        </member>
        <member name="T:Orleans.Storage.MemoryStorageGrain">
            <summary>
            Implementaiton class for the Storage Grain used by In-memory storage provider
            <c>Orleans.Storage.MemoryStorage</c>
            </summary>
        </member>
        <member name="T:Orleans.Storage.MemoryStorageGrain.GrainStateStore.DeletedState">
            <summary>
            Marker to record deleted state so we can detect the difference between deleted state and state that never existed.
            </summary>
        </member>
    </members>
</doc>
